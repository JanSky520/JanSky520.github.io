[{"content":"列表处理 对未曾接触过的人来说，Lisp 是一种奇怪的编程语言。在 Lisp 代码中，到处都是括号。有些人甚至戏称其名称代表“Lots of Isolated Silly Parentheses”（大量孤立的愚蠢括号）。但这种说法是没有依据的。 Lisp 实际上代表的是“LISt Processing”（列表处理），这门编程语言通过将列表（以及列表的列表）置于括号之间来处理它们。括号标志着列表的边界。有时列表前会有一个单引号‘\u0026rsquo;’，在 Lisp 中称为单引号。列表是 Lisp 的基础。\nLisp 中的列表 在 Lisp 中，一个列表看起来像这样：\u0026rsquo;(rose violet daisy buttercup)。这个列表前有一个单引号。它也可以写成如下形式，看起来更像你可能熟悉的那种列表：\n1 2 3 4 \u0026#39;(rose violet daisy buttercup) 这个列表的元素是四种不同的花的名称，彼此之间用空白分隔，并被括号包围，就像田野里用石墙围起来的花朵一样。\n数字，列表中的列表 列表中也可以包含数字，如在这个列表中：(+ 2 2)。这个列表包含一个加号 ‘+’，后面跟着两个数字 ‘2’，它们之间用空格分隔。\n在 Lisp 中，数据和程序的表示方式是相同的；也就是说，它们都是由单词、数字或其他列表组成的列表，彼此之间用空格分隔，并被括号包围。（由于程序看起来像数据，一个程序很容易作为另一个程序的数据使用；这是 Lisp 的一个非常强大的功能。）\n这里是另一个列表，这次其中包含一个列表：\n1 \u0026#39;(this list has (a list inside of it)) 这个列表的组件是单词 ‘this’、‘list’、‘has’ 和列表 ‘(a list inside of it)’。内部列表由单词 ‘a’、‘list’、‘inside’、‘of’、‘it’ 组成。\nLisp中的原子 在Lisp中，我们所称的“单词”被称为“原子”。这个术语源自“原子”一词的历史含义，意思是“不可分割”。就Lisp而言，我们在列表中使用的单词不能再分解为更小的部分，否则它们在程序中的意义就不再相同；数字和像‘+’这样的单字符符号也是如此。另一方面，与古代原子不同，列表可以被分解为多个部分。（参见car、cdr和cons基本函数。）\n在一个列表中，原子之间用空格分隔。它们可以紧挨着括号。\n从技术上讲，Lisp中的列表由括号组成，括号内包含由空格分隔的原子、其他列表或同时包含原子和其他列表。一个列表可以只有一个原子，也可以什么都没有。一个空列表看起来像这样：`()`，被称为“空列表”。与其他任何东西不同，空列表同时被视为原子和列表。\n原子和列表的打印表示被称为符号表达式，或更简洁地称为s-表达式。单独的“表达式”一词可以指打印表示，也可以指计算机内部存储的原子或列表。通常，人们会随意使用“表达式”这一术语。（另外，在许多文本中，“形式”一词也被用作“表达式”的同义词。）\n顺便提一下，当原子被认为是不可分割时，它们才被命名为“原子”；但后来发现物理原子并非不可分割。原子的一部分可以分裂出来，或者它可以裂变成两部分，且这两部分大小大致相等。物理原子的命名过于仓促，在其真实本质被发现之前就被命名了。在Lisp中，某些类型的原子，如数组，可以分为多个部分；但实现这一操作的机制与分裂列表的机制不同。就列表操作而言，列表中的原子是不可分割的。\n与英语类似，Lisp 原子的组成字母的含义与这些字母组合成单词后的含义是不同的。例如，南美洲树懒的名称“ai”与两个单词“a”和“i”的含义完全不同。\n在自然界中有很多种原子，但在 Lisp 中只有几种：例如，数字，如 37、511 或 1729；以及符号，如‘+’、‘foo’或‘forward-line’。我们在上面例子中列出的单词都是符号。在日常的 Lisp 对话中，\u0026ldquo;原子\u0026rdquo; 这个词不常用，因为程序员通常会更具体地说明他们正在处理的原子类型。 Lisp 编程主要涉及列表中的符号（有时也包括数字）。顺便说一下，前面三个单词构成的括号中的注释是一个符合 Lisp 规范的列表，因为它由原子（在这种情况下是符号）组成，这些符号用空格分隔并用括号括起来，没有任何非 Lisp 的标点符号。\n双引号中的文本——即使是句子或段落——也是一个原子。以下是一个例子：\n1 \u0026#39;(this list includes \u0026#34;text between quotation marks.\u0026#34;) 在 Lisp 中，所有被引号包围的文本，包括标点符号和空格，都被视为一个单一的原子。这种原子称为字符串（\u0026ldquo;字符串\u0026rdquo;），通常用于计算机打印给人类阅读的消息。字符串是一种与数字或符号不同的原子，其使用方式也不同。\n列表中的空白 列表中的空白量并不重要。从 Lisp 语言的角度来看：\n1 2 \u0026#39;(this list looks like this) 与这个列表是完全相同的：\n1 \u0026#39;(this list looks like this) 这两个例子展示的在 Lisp 中是同一个列表，即由符号‘this’、‘list’、‘looks’、‘like’和‘this’按顺序组成的列表。\n额外的空白和换行是为了让列表更易于人类阅读。当 Lisp 读取表达式时，它会去除所有多余的空白（但在原子之间至少需要有一个空格，以便区分它们）。\n虽然看起来有点奇怪，但我们看到的这些例子几乎涵盖了 Lisp 列表的所有形式！在 Lisp 中的其他列表或多或少都类似于这些例子，只是列表可能会更长、更复杂。简而言之，一个列表在括号之间，一个字符串在引号之间，一个符号看起来像一个单词，一个数字看起来像一个数字。（在某些情况下，方括号、点和其他一些特殊字符可能会被使用；然而，我们在大多数情况下都不需要它们。）\nGNU Emacs 帮助你编写列表 当你在 GNU Emacs 中使用 Lisp 交互模式或 Emacs Lisp 模式输入 Lisp 表达式时，你可以使用多个命令来格式化 Lisp 表达式，使其更易于阅读。例如，按下 TAB 键会自动将光标所在的行缩进到正确的位置。通常，将代码区域正确缩进的命令绑定在 M-C-\\ 键上。缩进的设计使你能够清楚地看到列表的哪些元素属于哪个列表——子列表的元素比外部列表的元素缩进更多。\n此外，当你输入一个右括号时，Emacs 会短暂地将光标跳回到匹配的左括号处，以便你确认它对应的是哪个左括号。这非常有用，因为在 Lisp 中你输入的每个列表都必须确保右括号与左括号匹配。（有关 Emacs 模式的更多信息，请参见《GNU Emacs 手册》中的“主要模式”部分。）\n运行程序 在 Lisp 中，任何列表都是一个准备运行的程序。如果你运行它（在 Lisp 中的术语是“求值”），计算机将执行以下三种情况之一：什么都不做，只是返回列表本身；向你发送错误消息；或者，将列表中的第一个符号视为命令并执行某些操作。\n我在前面部分的一些示例列表前面加的单引号 `’` 被称为“引用”；当它位于列表前时，它告诉 Lisp 对列表不做任何处理，只是按原样接受它。但是，如果列表前没有引用符号，列表的第一个元素是特殊的：它是计算机必须执行的命令。（在 Lisp 中，这些命令被称为“函数”。）上面显示的列表 `(+ 2 2)` 前面没有引用符号，因此 Lisp 理解 `+` 是一个指令，要求对列表的其余部分进行处理：将后续的数字相加。\n如果你在 GNU Emacs 的 Info 中阅读此内容，通过这样对列表进行求值：将光标放在以下列表的右括号之后，然后键入 `C-x C-e`：\n1 (+ 2 2) 你会看到数字 4 出现在回显区域（你刚刚做的就是对列表求值。回显区域是屏幕底部显示或回显文本的那一行）。现在，尝试对一个带有引用符号的列表做同样的操作：将光标放在以下列表的右括号之后，然后键入 `C-x C-e`：\n1 \u0026#39;(this is a quoted list) 你会看到 `(this is a quoted list)` 出现在回显区域。\n在这两种情况下，你所做的都是向 GNU Emacs 内的一个名为 Lisp 解释器的程序发出命令，要求解释器对表达式进行求值。 Lisp 解释器的名称源自于一个人为表达式赋予意义并解释它的任务。\n你也可以对不在列表中的原子进行求值——即那些没有被括号包围的原子；同样，Lisp 解释器会将人类可读的表达式翻译成计算机语言。但在讨论这个之前（见变量），我们将先讨论当你出错时 Lisp 解释器会做什么。\n生成错误消息 为了让你在不小心做错时不会过于担心，我们现在将向 Lisp 解释器发出一个命令，以生成错误消息。这是一个无害的操作；实际上，我们经常会故意生成错误消息。一旦你理解了术语，错误消息实际上是很有帮助的。与其称它们为“错误”消息，不如称它们为“帮助”消息。它们就像在陌生国度中的路标；虽然解读它们可能很难，但一旦理解了，它们就能指明方向。\n错误消息由 GNU Emacs 内置的调试器生成。我们将进入调试器。你可以通过输入 `q` 退出调试器。\n我们要做的是对一个未引用且第一个元素不是有效命令的列表进行求值。下面是一个几乎与我们刚刚使用的列表完全相同的列表，但没有前面的单引号。将光标放在列表之后，然后输入 `C-x C-e`：\n1 (this is an unquoted list) 一个 Backtrace 窗口将会打开，你应该在其中看到以下内容：\n1 2 3 4 5 6 7 8 9 10 ---------- Buffer: *Backtrace* ---------- Debugger entered--Lisp error: (void-function this) (this is an unquoted list) eval((this is an unquoted list) nil) elisp--eval-last-sexp(nil) eval-last-sexp(nil) funcall-interactively(eval-last-sexp nil) call-interactively(eval-last-sexp nil nil) command-execute(eval-last-sexp) ---------- Buffer: *Backtrace* ---------- 你的光标将位于这个窗口中（你可能需要等待几秒钟才会看到它）。要退出调试器并关闭调试器窗口，输入：q 基于我们已经知道的内容，我们几乎可以理解这个错误消息。\n你应该从下往上读取 Backtrace 缓冲区；它告诉你 Emacs 做了什么。当你输入 C-x C-e 时，你进行了对命令 eval-last-sexp 的交互调用。 eval 是 \u0026ldquo;evaluate\u0026rdquo;（求值）的缩写，而 sexp 是 \u0026ldquo;symbolic expression\u0026rdquo;（符号表达式）的缩写。该命令的意思是 \u0026ldquo;求值最后一个符号表达式\u0026rdquo;，也就是光标前面的那个表达式。\n上面的每一行告诉你 Lisp 解释器接下来求值的内容。最近的操作在最上面。这个缓冲区被称为 Backtrace 缓冲区，因为它让你能够追踪 Emacs 的操作顺序。\n在 Backtrace 缓冲区的顶部，你会看到这一行：\n1 Debugger entered--Lisp error: (void-function this) Lisp 解释器试图求值列表的第一个原子，即单词 \u0026rsquo;this\u0026rsquo;。正是这个操作产生了错误消息 \u0026lsquo;void-function this\u0026rsquo;。\n消息中包含了 \u0026lsquo;void-function\u0026rsquo; 和 \u0026rsquo;this\u0026rsquo; 这两个词。\n‘function’ 这个词之前提到过一次。它是一个非常重要的词。对于我们的目的，我们可以这样定义它：函数是一组给计算机的指令，告诉计算机执行某些操作。\n现在我们可以开始理解这个错误消息：\u0026lsquo;void-function this\u0026rsquo;。函数（即单词 \u0026rsquo;this\u0026rsquo;）没有定义任何一组指令让计算机执行。\n这个略显奇怪的词语 \u0026lsquo;void-function\u0026rsquo; 是为了说明 Emacs Lisp 的实现方式，即当一个符号没有附加函数定义时，应该包含指令的位置是空的。\n另一方面，由于我们能够通过求值 (+ 2 2) 成功地得到 2 加 2 的结果，我们可以推断出符号 + 必定有一组指令让计算机遵循，而这些指令必须是将 `+` 后面的数字相加。\n可以避免在这种情况下 Emacs 进入调试器。我们在这里不解释如何做到这一点，但我们会提到结果是什么样的，因为如果你在使用的某些 Emacs 代码中遇到错误，你可能会遇到类似的情况。在这种情况下，你只会看到一行错误消息；它会出现在回显区域，看起来像这样：\n1 Symbol\u0026#39;s function definition is void: this 当你输入一个按键时，哪怕只是移动光标，消息就会消失。\n我们已经知道 “Symbol” 这个词的含义。它指的是列表的第一个原子，即单词 “this”。“function” 这个词指的是告诉计算机该做什么的指令。（从技术上讲，符号告诉计算机在哪里找到指令，但这是一个我们目前可以忽略的复杂问题。）\n这个错误消息可以理解为：‘Symbol\u0026rsquo;s function definition is void: this’。符号（即单词 “this”）缺少让计算机执行的指令。\n符号名称与函数定义 基于我们迄今为止讨论的内容，我们可以明确 Lisp 的另一个特征——一个重要的特征：像 + 这样的符号本身并不是计算机要执行的那组指令。相反，符号可能只是暂时用来定位定义或指令集的一种方式。我们所看到的是用来找到这些指令的名称。人的名字也是同样的道理。我可以被称为 \u0026ldquo;Bob\u0026rdquo;；然而，我并不是字母 \u0026ldquo;B\u0026rdquo;、\u0026ldquo;o\u0026rdquo;、\u0026ldquo;b\u0026rdquo;，而是（或曾经是）与某个特定生命形式一致关联的意识。名字并不是我本身，但它可以用来指代我。\n在 Lisp 中，一组指令可以附加到多个名称上。例如，用于加法运算的计算机指令可以同时链接到符号 plus 和符号 + （在某些 Lisp 方言中就是如此）。在人类社会中，我可以被称为 \u0026ldquo;Robert\u0026rdquo; 或 \u0026ldquo;Bob\u0026rdquo; 以及其他名字。\n另一方面，一个符号在同一时间只能有一个函数定义与之关联。否则，计算机会因为不知道使用哪个定义而感到困惑。如果在人类社会中也存在这种情况，那么世界上只有一个人可以叫 \u0026ldquo;Bob\u0026rdquo;。不过，符号名称所指向的函数定义可以轻松更改。（参见《设置函数定义》）。\n由于 Emacs Lisp 规模庞大，通常习惯于为符号命名，以便识别该函数所属的 Emacs 部分。因此，处理 Texinfo 的所有函数名称都以 \u0026ldquo;texinfo-\u0026rdquo; 开头，而处理邮件读取的函数名称则以 \u0026ldquo;rmail-\u0026rdquo; 开头。\nLisp 解释器 基于我们所见的内容，我们现在可以开始理解 Lisp 解释器在我们命令它求值一个列表时的工作原理。首先，它查看列表前是否有引号；如果有，引擎解释器就直接返回列表。另一方面，如果没有引号，解释器会查看列表中的第一个元素，并检查它是否有函数定义。如果有，解释器就执行函数定义中的指令。否则，解释器会打印一条错误消息。\n这就是 Lisp 的工作原理，很简单。接下来我们还会探讨一些额外的复杂情况，但这些是基本原理。当然，要编写 Lisp 程序，你需要知道如何编写函数定义并将其附加到名称上，以及如何在不让自己或计算机混淆的情况下做到这一点。\n复杂情况 现在，我们来探讨第一个复杂情况。除了列表外，Lisp 解释器还可以求值一个未加引号且没有括号的符号。 Lisp 解释器会尝试将该符号的值作为变量来确定。这种情况在变量部分有描述。（参见《变量》）。\n第二个复杂情况出现是因为有些函数不常见，它们的工作方式与常规方法不同。这些不常规的函数被称为特殊形式（special forms）。它们用于一些特殊的任务，比如定义函数，而且数量不多。在接下来的几章中，你将会接触到一些较为重要的特殊形式。\n除了特殊形式，还有宏。宏是 Lisp 中定义的一种结构，它与函数的不同之处在于，宏将一个 Lisp 表达式翻译为另一个表达式，以替代原始表达式进行求值。（参见《Lisp 宏》）。\n对于本介绍的目的，你不需要过于担心某个东西是特殊形式、宏，还是普通函数。例如，if 是一种特殊形式（参见《if 特殊形式》），但 when 是一种宏（参见《Lisp 宏》）。在早期版本的 Emacs 中，defun 是一种特殊形式，但现在它是一种宏（参见《defun 宏》）。不过，它的行为仍然相同。\n最后一个复杂情况是：如果 Lisp 解释器所查看的函数不是特殊形式，并且它是列表的一部分，解释器会查看该列表中是否包含另一个列表。如果存在内部列表，Lisp 解释器首先会确定如何处理该内部列表，然后再处理外部列表。如果内部列表中还有嵌套的列表，解释器会先处理那个嵌套的列表，以此类推。它总是首先处理最内层的列表。解释器首先处理最内层的列表，以求值该列表的结果。该结果可能会被外层表达式使用。\n否则，解释器会从左到右依次处理每个表达式。\n字节编译 关于解释的另一个方面：Lisp 解释器能够解释两种实体：人类可读的代码（我们将专注于此），以及经过特殊处理的代码，称为字节编译代码，这种代码不可供人类阅读。字节编译代码的运行速度比人类可读代码更快。\n你可以通过运行 byte-compile-file 等编译命令之一，将人类可读代码转换为字节编译代码。字节编译代码通常存储在以 .elc 为扩展名的文件中，而不是 .el 扩展名的文件中。在 emacs/lisp 目录中你会看到这两种类型的文件；需要阅读的是扩展名为 .el 的文件。\n实际上，对于大多数自定义或扩展 Emacs 的操作，你不需要进行字节编译，因此我在此不会讨论这一话题。有关字节编译的完整描述，请参见《GNU Emacs Lisp 参考手册》中的字节编译部分。\n求值 当 Lisp 解释器处理一个表达式时，这一活动被称为求值。我们说解释器“对表达式进行求值”。我之前已经多次使用过这个术语。根据《韦氏新大学词典》，这个词源自日常语言的用法，意为“确定价值或数量；评估”。\nLisp 解释器的行为 在对一个表达式求值之后，Lisp 解释器很可能会返回计算机通过执行函数定义中的指令所产生的值，或者可能会放弃该函数并产生一条错误消息。（解释器也可能被“抛到”另一个函数中，或者可能会试图在无限循环中不断重复它正在做的事情。这些行为较为少见，我们可以忽略它们。）最常见的是，解释器会返回一个值。\n在解释器返回一个值的同时，它也可能会执行其他操作，例如移动光标或复制文件；这种类型的操作被称为副作用。对我们人类来说很重要的操作，比如打印结果，对于 Lisp 解释器来说通常是副作用。学习如何使用副作用相对容易。\n总而言之，对符号表达式进行求值通常会导致 Lisp 解释器返回一个值，并可能执行一个副作用；否则会产生一个错误。\n求值内部列表 如果求值作用于嵌套在另一个列表中的列表，则外部列表在求值时可能会使用第一次求值返回的值作为信息。这就解释了为什么先对内部表达式进行求值：它们返回的值会被外部表达式使用。\n我们可以通过求值另一个加法示例来探究这一过程。将光标放在以下表达式之后，然后输入 C-x C-e：\n1 (+ 2 (+ 3 3)) 数字 8 会出现在回显区域。\n发生的情况是，Lisp 解释器首先对内部表达式 (+ 3 3) 进行求值，返回的值是 6；然后，它对外部表达式求值，仿佛它是 (+ 2 6)，结果返回值是 8。由于没有更多的外部表达式需要求值，解释器将该值打印在回显区域。\n现在，C-x C-e 这一组合键调用的命令名称变得容易理解了：这个命令的名称是 eval-last-sexp。 sexp 是 “symbolic expression”（符号表达式）的缩写，而 eval 是 “evaluate”（求值）的缩写。该命令对最后一个符号表达式进行求值。\n作为实验，你可以尝试将光标放在表达式后面的下一行的开头，或者放在表达式内部，然后对该表达式进行求值。\n以下是该表达式的另一个副本：\n1 (+ 2 (+ 3 3)) 如果你将光标放在紧跟表达式之后的空白行的开头，并输入 C-x C-e，你仍然会在回显区域看到数字 8。现在尝试将光标放在表达式内部。如果你将光标放在倒数第二个括号之后（所以看起来它位于最后一个括号上方），你会在回显区域看到数字 6！这是因为该命令对表达式 (+ 3 3) 进行了求值。\n现在将光标放在数字之后。输入 C-x C-e，你将得到这个数字本身。在 Lisp 中，如果你对一个数字进行求值，你会得到这个数字本身——这就是数字与符号的区别。如果你对以 + 等符号开头的列表进行求值，你会得到计算机执行与该名称关联的函数定义中的指令后的结果。如果对符号本身进行求值，则会发生不同的情况，我们将在下一节中看到。\n变量 在 Emacs Lisp 中，一个符号可以附加一个值，就像它可以附加一个函数定义一样。两者是不同的。函数定义是一组计算机将执行的指令。而一个值则是某种可以变化的东西，比如数字或名字（这也是为什么这样的符号被称为变量）。符号的值可以是 Lisp 中的任何表达式，例如符号、数字、列表或字符串。一个有值的符号通常被称为变量。\n一个符号可以同时附加函数定义和值，也可以只附加其中一个。这两者是独立的。这有点类似于“剑桥”这个名字既可以指代马萨诸塞州的城市，也可以附加一些信息，比如“著名的编程中心”。\n另一种理解方式是将符号想象成一个有抽屉的柜子。函数定义放在一个抽屉里，值放在另一个抽屉里，等等。存放值的抽屉中的内容可以更改，而不会影响存放函数定义的抽屉中的内容，反之亦然。\nfill-column，一个示例变量 变量 fill-column 说明了一个附加了值的符号：在每个 GNU Emacs 缓冲区中，这个符号都被设置为某个值，通常是 72 或 70，但有时也会设置为其他值。要查看这个符号的值，可以直接对其进行求值。如果你正在 GNU Emacs 中的 Info 阅读此内容，你可以将光标放在符号后面，然后按 C-x C-e：\n1 fill-column 当我输入 `C-x C-e` 后，Emacs 在回显区域显示了数字 72。这是我在编写这段文字时 fill-column 被设置的值。在你的 Info 缓冲区中，这个值可能不同。请注意，作为变量返回的值和函数执行其指令后返回的值，其显示方式完全相同。从 Lisp 解释器的角度来看，返回的值就是返回的值。一旦知道了这个值，它来自什么表达式就不再重要了。\n一个符号可以附加任何值，或者用行话来说，我们可以将变量绑定到一个值：可以是一个数字，比如 72；可以是一个字符串，比如 \u0026ldquo;such as this\u0026rdquo;；可以是一个列表，比如 (spruce pine oak)；我们甚至可以将一个变量绑定到一个函数定义。\n符号可以通过几种方式绑定到一个值。有关其中一种方式的信息，请参阅“设置变量的值”。\n没有函数的符号的错误信息 当我们对 fill-column 求值以查看其作为变量的值时，没有在这个词周围加上括号。这是因为我们并不打算将其用作函数名。\n如果 fill-column 是列表中的第一个或唯一元素，Lisp 解释器将尝试查找附加给它的函数定义。但 fill-column 并没有函数定义。试着对以下内容求值：\n1 (fill-column) 你会创建一个名为 Backtrace 的缓冲区，其中显示：\n1 2 3 4 5 6 7 8 9 10 ---------- Buffer: *Backtrace* ---------- Debugger entered--Lisp error: (void-function fill-column) (fill-column) eval((fill-column) nil) elisp--eval-last-sexp(nil) eval-last-sexp(nil) funcall-interactively(eval-last-sexp nil) call-interactively(eval-last-sexp nil nil) command-execute(eval-last-sexp) ---------- Buffer: *Backtrace* ---------- （记住，要退出调试器并关闭调试器窗口，在 Backtrace 缓冲区中输入 q。）\n没有值的符号的错误信息 如果你尝试对一个没有绑定值的符号进行求值，你将收到一条错误信息。你可以通过尝试我们的 2 加 2 来看到这一点。在以下表达式中，将光标放在 + 后面、第一个数字 2 之前，然后输入 C-x C-e：\n1 (+ 2 2) 在 GNU Emacs 22 中，你会创建一个名为 Backtrace 的缓冲区，其中显示：\n1 2 3 4 5 6 7 8 9 ---------- Buffer: *Backtrace* ---------- Debugger entered--Lisp error: (void-variable +) eval(+) elisp--eval-last-sexp(nil) eval-last-sexp(nil) funcall-interactively(eval-last-sexp nil) call-interactively(eval-last-sexp nil nil) command-execute(eval-last-sexp) ---------- Buffer: *Backtrace* ---------- （同样，你可以通过在 Backtrace 缓冲区中输入 q 来退出调试器。）\n这个回溯与我们看到的第一个错误信息不同，第一个错误信息显示为“Debugger entered\u0026ndash;Lisp error: (void-function this)”。在这个案例中，函数没有作为变量的值；而在另一个错误信息中，函数（“this”这个词）没有定义。\n在我们对 + 进行的实验中，我们让 Lisp 解释器对 + 进行求值，并查找变量的值，而不是函数定义。我们通过将光标放在符号后面，而不是像之前那样放在封闭列表的括号后面来实现这一点。结果，Lisp 解释器求值了前面的 s-表达式，在这种情况下就是 + 本身。\n由于 + 没有绑定任何值，只有函数定义，因此错误信息报告该符号作为变量的值为空。\n参数 为了了解信息如何传递给函数，我们再次来看一下我们熟悉的例子，即两个数相加。在 Lisp 中，这样写：\n1 (+ 2 2) 如果你对这个表达式求值，数字 4 会出现在你的回显区域。Lisp 解释器的作用是将 + 后面的数字相加。\n这些被 + 加起来的数字被称为函数 + 的参数。这些数字是传递给函数的信息。\n“参数”一词来源于数学中的用法，并不指两个人之间的争论；相反，它指的是传递给函数的信息，在这个例子中就是传递给 + 的信息。在 Lisp 中，函数的参数是跟在函数后面的原子或列表。通过对这些原子或列表求值获得的值会传递给函数。不同的函数需要不同数量的参数，有些函数甚至不需要参数。\n参数的数据类型 传递给函数的数据类型取决于函数使用的信息类型。像 + 这样的函数，其参数必须是数值，因为 + 是用来进行数值相加的。而其他函数则会使用不同类型的数据作为参数。\n例如，concat 函数将两个或多个文本字符串连接在一起，生成一个新的字符串。它的参数是字符串。将两个字符串 \u0026ldquo;abc\u0026rdquo; 和 \u0026ldquo;def\u0026rdquo; 连接起来会生成单一字符串 \u0026ldquo;abcdef\u0026rdquo;。你可以通过对以下表达式求值来验证这一点：\n1 (concat \u0026#34;abc\u0026#34; \u0026#34;def\u0026#34;) 对这个表达式求值的结果是 \u0026ldquo;abcdef\u0026rdquo;。\n像 substring 这样的函数则会同时使用字符串和数字作为参数。这个函数返回字符串的一部分，即第一个参数的子字符串。 substring 函数接受三个参数。第一个参数是字符字符串，第二个和第三个参数是数字，用于指示子字符串的起始位置（包含）和结束位置（不包含）。这些数字表示从字符串开头起字符（包括空格和标点符号）的计数。请注意，字符串中的字符编号从零开始，而不是从一开始。\n例如，如果你对以下表达式求值：\n1 (substring \u0026#34;The quick brown fox jumped.\u0026#34; 16 19) 你会在回显区域看到 \u0026ldquo;fox\u0026rdquo;。这些参数包括字符串和两个数字。\n请注意，传递给 substring 的字符串虽然由几个用空格分隔的单词组成，但它仍然是一个单一的原子。 Lisp 将两个引号之间的所有内容都视为字符串的一部分，包括空格。你可以将 substring 函数视为一种“原子粉碎机”，因为它能够从一个不可分割的原子中提取出一部分。不过，substring 只能从字符串类型的参数中提取子字符串，不能从其他类型的原子（如数字或符号）中提取。\n作为变量或列表值的参数 参数可以是一个符号，当对其求值时会返回一个值。例如，当单独对符号 fill-column 求值时，它会返回一个数字。这个数字可以用于加法运算中。\n将光标放在以下表达式后面，然后输入 C-x C-e：\n1 (+ 2 fill-column) 结果将是一个比单独求值 fill-column 时多出 2 的数字。对我来说，这是 74，因为我的 fill-column 值是 72。\n正如我们刚刚看到的，参数可以是一个符号，在求值时返回一个值。此外，参数还可以是一个列表，在求值时返回一个值。例如，在以下表达式中，函数 concat 的参数是字符串 \u0026ldquo;The \u0026quot; 和 \u0026quot; red foxes.\u0026rdquo; 以及列表 (number-to-string (+ 2 fill-column))。\n1 (concat \u0026#34;The \u0026#34; (number-to-string (+ 2 fill-column)) \u0026#34; red foxes.\u0026#34;) 如果你对这个表达式求值——并且如果你的 Emacs 中 fill-column 的值为 72——那么回显区域中将显示 \u0026ldquo;The 74 red foxes.\u0026quot;。（注意，你必须在单词 \u0026ldquo;The\u0026rdquo; 后和单词 \u0026ldquo;red\u0026rdquo; 前加上空格，这样它们才会出现在最终的字符串中。 number-to-string 函数将加法函数返回的整数转换为字符串。number-to-string 也被称为 int-to-string。）\n可变数量的参数 一些函数，例如 concat、+ 或 ，可以接受任意数量的参数。（ 是乘法的符号。）你可以通过对以下每个表达式按常规方式求值来验证这一点。回显区域中显示的结果在文本中用 ⇒ 表示，你可以将其理解为“求值结果为”。\n在第一组中，这些函数没有参数：\n1 2 3 (+) ⇒ 0 (*) ⇒ 1 在这一组中，每个函数有一个参数：\n1 2 3 (+ 3) ⇒ 3 (* 3) ⇒ 3 在这一组中，每个函数有三个参数：\n1 2 3 (+ 3 4 5) ⇒ 12 (* 3 4 5) ⇒ 60 使用错误类型的对象作为参数 当一个函数被传递了错误类型的参数时，Lisp 解释器会生成一条错误消息。例如，+ 函数期望其参数的值是数字。作为实验，我们可以传递一个引用的符号 hello 而不是数字。将光标放在以下表达式后面，然后输入 C-x C-e：\n1 (+ 2 \u0026#39;hello) 当你这样做时，会生成一条错误消息。发生的情况是，+ 试图将 2 与 hello 返回的值相加，但 hello 返回的值是符号 hello，而不是一个数字。只有数字才能相加，所以 + 无法执行加法操作。\n你将创建并进入一个名为 Backtrace 的缓冲区，其中显示：\n1 2 3 4 5 6 7 8 9 10 11 ---------- Buffer: *Backtrace* ---------- Debugger entered--Lisp error: (wrong-type-argument number-or-marker-p hello) +(2 hello) eval((+ 2 \u0026#39;hello) nil) elisp--eval-last-sexp(t) eval-last-sexp(nil) funcall-interactively(eval-print-last-sexp nil) call-interactively(eval-print-last-sexp nil nil) command-execute(eval-print-last-sexp) ---------- Buffer: *Backtrace* ---------- 像往常一样，错误信息试图提供帮助，并在你学会如何解读它之后变得容易理解。\n错误消息的第一部分很直接，提示“错误的类型参数”（wrong type argument）。接下来是一个看起来神秘的术语“number-or-marker-p”。这个术语试图告诉你 + 函数期望接收到哪种类型的参数。\n符号 number-or-marker-p 表示 Lisp 解释器正在尝试确定提供给它的信息（参数的值）是否为数字或标记（代表缓冲区位置的特殊对象）。它的作用是测试 + 函数是否接收到可以相加的数字。它还测试参数是否是被称为标记的东西，这是一种 Emacs Lisp 的特定功能。（在 Emacs 中，缓冲区中的位置记录为标记。当使用 C-@ 或 C-SPC 命令设置标记时，其位置作为标记保存。标记可以被视为一个数字——该位置距缓冲区起始位置的字符数。）在 Emacs Lisp 中，`+` 可以用于将标记位置的数值相加。\nnumber-or-marker-p 中的 p 是早期 Lisp 编程实践的体现。p 代表谓词（predicate）。在早期 Lisp 研究者使用的术语中，谓词指的是一个判断某个属性是“真”还是“假”的函数。因此，p 告诉我们 number-or-marker-p 是一个函数的名称，该函数用于判断提供的参数是否为数字或标记。其他以 p 结尾的 Lisp 符号包括 zerop（一个测试其参数是否为零的函数）和 listp（一个测试其参数是否为列表的函数）。\n最后，错误消息的最后一部分是符号 hello。这是传递给 + 的参数的值。如果传递给 + 的参数是正确类型的对象，这个值会是一个数字，例如 37，而不是像 hello 这样的符号。但在那种情况下，你就不会收到错误信息了。\nmessage 函数 和 + 函数一样，message 函数也可以接受可变数量的参数。它用于向用户发送消息，非常有用，因此我们将在这里介绍它。\n消息会显示在回显区域。例如，你可以通过对以下列表求值，将一条消息打印在你的回显区域中：\n1 (message \u0026#34;This message appears in the echo area!\u0026#34;) 双引号之间的整个字符串是一个单一的参数，并将被完整打印。（注意，在这个例子中，消息本身会在回显区域中显示在双引号内；这是因为你看到了 message 函数返回的值。在你编写的程序中，大多数使用 message 的情况下，文本会作为副作用打印在回显区域，而不会带有引号。有关此类示例，请参阅 multiply-by-seven 的详细介绍。）\n然而，如果在引用的字符串中有一个 \u0026lsquo;%s\u0026rsquo;，message 函数不会按原样打印 \u0026lsquo;%s\u0026rsquo;，而是会查找字符串之后的参数。它会对第二个参数求值，并在字符串中 `\u0026rsquo;%s\u0026rsquo;` 所在的位置打印该值。\n你可以通过将光标放在以下表达式后并输入 C-x C-e 来验证这一点：\n1 (message \u0026#34;The name of this buffer is: %s.\u0026#34; (buffer-name)) 在 Info 中，回显区域会显示 \u0026ldquo;The name of this buffer is: info.\u0026quot;。 buffer-name 函数返回缓冲区的名称作为字符串，message 函数将其插入 %s 的位置。\n要将一个值以整数形式打印，可以像使用 %s 一样使用 %d。例如，要在回显区域中打印 `fill-column` 的值，可以对以下表达式求值：\n1 (message \u0026#34;The value of fill-column is %d.\u0026#34; fill-column) 在我的系统上，当我对这个列表求值时，回显区域会显示 \u0026ldquo;The value of fill-column is 72.\u0026quot;。\n如果引用的字符串中有多个 %s，第一个 %s 位置会打印引用字符串后第一个参数的值，第二个 %s 位置会打印第二个参数的值，依此类推。\n例如，如果你对以下表达式求值：\n1 2 (message \u0026#34;There are %d %s in the office!\u0026#34; (- fill-column 14) \u0026#34;pink elephants\u0026#34;) 在你的回显区域中会出现一条相当异想天开的消息。在我的系统上，它显示为 \u0026ldquo;There are 58 pink elephants in the office!\u0026quot;。\n表达式 (- fill-column 14) 会被求值，得到的数字将被插入到 %d 的位置；而双引号中的字符串 \u0026ldquo;pink elephants\u0026rdquo; 被视为一个单独的参数，并被插入到 %s 的位置。（也就是说，双引号之间的字符串求值为其自身，就像数字一样。）\n最后，这是一个稍微复杂的例子，不仅说明了如何计算一个数字，还展示了如何在表达式中使用另一个表达式来生成替换 %s 的文本：\n1 2 3 4 5 6 (message \u0026#34;He saw %d %s\u0026#34; (- fill-column 32) (concat \u0026#34;red \u0026#34; (substring \u0026#34;The quick brown foxes jumped.\u0026#34; 16 21) \u0026#34; leaping.\u0026#34;)) 在这个例子中，message 有三个参数：字符串 \u0026ldquo;He saw %d %s\u0026rdquo;，表达式 (- fill-column 32)，以及以 concat 函数开头的表达式。 (- fill-column 32) 的求值结果被插入到 %d 的位置，而 concat 表达式的返回值则被插入到 %s 的位置。\n当你的 fill-column 值为 70 并且你对这个表达式求值时，回显区域会显示消息 \u0026ldquo;He saw 38 red foxes leaping.\u0026quot;。\n设置变量的值 有几种方法可以为变量赋值。其中一种方法是使用特殊形式 setq。另一种方法是使用 let（参见 let）。在专业术语中，这个过程称为将变量绑定到一个值。\n以下部分不仅描述了 setq 的工作原理，还说明了参数是如何传递的。\n使用 setq 要将符号 flowers 的值设置为列表 (rose violet daisy buttercup)，请通过将光标放在表达式后面并按下 C-x C-e 来对以下表达式求值：\n1 (setq flowers \u0026#39;(rose violet daisy buttercup)) 回显区域会显示列表 (rose violet daisy buttercup)，这是 setq 特殊形式返回的内容。作为副作用，符号 flowers 被绑定到该列表；也就是说，符号 flowers，可以视为一个变量，被赋予了这个列表作为其值。（顺便说一下，这个过程说明了对 Lisp 解释器设置值的副作用可以是我们人类感兴趣的主要效果。这是因为每个 Lisp 函数必须返回一个值，除非它遇到错误，但它只有在被设计为具有副作用时才会有副作用。）\n在对 setq 表达式求值后，你可以对符号 flowers 求值，它将返回你刚刚设置的值。以下是这个符号。将光标放在它后面并输入 C-x C-e。\n1 flowers 当你对 flowers 求值时，回显区域会显示列表 (rose violet daisy buttercup)。\n顺便提一下，如果你对带有前置单引号的变量 \u0026lsquo;flowers 求值，你将在回显区域看到的是符号本身，即 flowers。以下是带有引号的符号，你可以试试这个：\n1 \u0026#39;flowers 另外，作为一种额外的方便，setq 允许你在一个表达式中为多个不同的变量设置不同的值。\n要使用 setq 将变量 carnivores 的值设置为列表 \u0026lsquo;(lion tiger leopard)，可以使用以下表达式：\n1 (setq carnivores \u0026#39;(lion tiger leopard)) 此外，setq 可以用来为不同的变量分配不同的值。第一个参数被绑定到第二个参数的值，第三个参数被绑定到第四个参数的值，依此类推。例如，你可以使用以下表达式将一组树的列表分配给符号 trees，并将一组食草动物的列表分配给符号 herbivores：\n1 2 (setq trees \u0026#39;(pine fir oak maple) herbivores \u0026#39;(gazelle antelope zebra)) （这个表达式同样可以放在一行上，但可能不适合在一页上显示；而且人类更容易阅读格式整齐的列表。）\n虽然我一直在使用“赋值”这个术语，但还有另一种理解 setq 工作方式的方式，那就是 setq 使符号指向列表。这种思维方式非常普遍，在后续章节中，我们将遇到至少一个名称中包含“指针”的符号。这个名称的选择是因为该符号有一个值，特别是一个列表，附加在它上面；或者换句话说，符号被设置为指向列表。\n计数 下面是一个使用 setq 进行计数的示例。这可以用于计算你的程序某部分重复执行的次数。首先，将一个变量设置为零；然后每次程序重复执行时，将这个数字加一。要做到这一点，你需要一个变量作为计数器，以及两个表达式：一个初始的 setq 表达式将计数器变量设置为零；第二个 setq 表达式在每次被计算时增加计数器的值。\n1 2 3 4 5 (setq counter 0) ; 这是初始化器。 (setq counter (+ counter 1)) ; 这是增量器。 counter ; 这是计数器。 （‘;’ 后的文字是注释。详见“更改函数定义”部分。）\n如果你计算第一个表达式，即初始化器 (setq counter 0)，然后计算第三个表达式 counter，回显区域将显示数字 0。如果你接着计算第二个表达式，即增量器 (setq counter (+ counter 1))，计数器将获得值 1。因此，如果你再次计算 counter，回显区域将显示数字 1。每次你计算第二个表达式，计数器的值都会增加。\n当你计算增量器 (setq counter (+ counter 1)) 时，Lisp 解释器首先计算最里面的列表，即加法。为了计算这个列表，它必须计算变量 counter 和数字 1。当它计算变量 counter 时，会获取其当前值。然后将这个值和数字 1 传递给 +，后者将它们相加。这个和作为内部列表的值返回，并传递给 setq，后者将变量 counter 设置为这个新值。因此，变量 counter 的值发生了变化。\n总结 学习 Lisp 就像爬山，最开始的部分是最陡峭的。你现在已经攀登了最困难的部分，接下来随着你的进步会变得越来越容易。\n总结如下：\nLisp 程序由表达式组成，表达式可以是列表或单个原子。 列表由零个或多个原子或内嵌列表组成，这些元素之间用空格分隔，并由括号包围。列表可以为空。 原子可以是多个字符组成的符号，如 forward-paragraph，也可以是单个字符的符号，如 +，或者是双引号括起来的字符串，或数字。 数字的值就是它本身。 双引号括起来的字符串的值也是它本身。 当你单独计算一个符号时，会返回它的值。 当你计算一个列表时，Lisp 解释器会查看列表中的第一个符号，然后查看绑定到该符号的函数定义。接着会执行函数定义中的指令。 单引号 \u0026rsquo; 告诉 Lisp 解释器返回紧随其后的表达式本身，而不是像没有引号时那样进行计算。 参数是传递给函数的信息。函数的参数是通过计算列表中除了第一个元素以外的其他元素得到的。 函数在被计算时总是返回一个值（除非出现错误）；此外，它还可能执行一些作为副作用的操作。在许多情况下，函数的主要目的是产生副作用。 练习 几个简单的练习：\n通过计算一个不在括号内的适当符号生成一条错误信息。 通过计算一个在括号内的适当符号生成一条错误信息。 创建一个每次递增2而不是1的计数器。 编写一个在计算时在回显区域打印信息的表达式。 练习计算 在学习如何编写 Emacs Lisp 函数定义之前，花一些时间计算已经编写的各种表达式是很有用的。这些表达式将是以函数作为其第一个（通常也是唯一的）元素的列表。由于与缓冲区相关的一些函数既简单又有趣，我们将从这些函数开始。在本节中，我们将计算其中的一些函数。在另一节中，我们将研究其他几个与缓冲区相关的函数的代码，看看它们是如何编写的。\n如何求值 每当你给 Emacs Lisp 一个编辑命令，例如移动光标或滚动屏幕的命令时，你都在对一个表达式求值，该表达式的第一个元素是一个函数。这就是 Emacs 的工作方式。\n当你输入按键时，你使 Lisp 解释器评估一个表达式，这就是你得到结果的方式。即使是输入普通文本也涉及评估一个 Emacs Lisp 函数，在这种情况下，这个函数使用 self-insert-command，它简单地插入你输入的字符。你通过按键输入来求值的函数被称为交互函数或命令；如何使一个函数变为交互式将在关于如何编写函数定义的章节中说明。参见“使一个函数变为交互式”。\n除了输入键盘命令，我们已经看到求值表达式的第二种方法：将光标定位在一个列表后面，然后按 C-x C-e。这是我们将在本节的其余部分中做的操作。还有其他对表达式求值的方法，我们将在遇到时描述它们。\n除了用于练习求值之外，接下来的几节中显示的函数本身也非常重要。学习这些函数可以清楚地区分缓冲区和文件、如何切换到缓冲区以及如何确定缓冲区中的位置。\n缓冲区名称 buffer-name 和 buffer-file-name 这两个函数展示了文件和缓冲区之间的区别。当你求值以下表达式 (buffer-name) 时，缓冲区的名称会出现在回显区域。当你求值 (buffer-file-name) 时，缓冲区所指向的文件的名称会出现在回显区域。通常，(buffer-name) 返回的名称与它所指向的文件的名称相同，而 (buffer-file-name) 返回的是文件的完整路径名。\n文件和缓冲区是两个不同的实体。文件是计算机中永久记录的信息（除非你删除它）。另一方面，缓冲区是 Emacs 中的信息，在编辑会话结束时（或当你杀死缓冲区时）会消失。通常，缓冲区包含你从文件中复制的信息；我们说缓冲区正在访问该文件。你所操作和修改的是这个副本。对缓冲区的更改不会更改文件，直到你保存缓冲区。当你保存缓冲区时，缓冲区会被复制到文件中，因此被永久保存。\n如果你在 GNU Emacs 的 Info 模式中阅读此内容，你可以将光标放在每个表达式后面并按 C-x C-e 来对它们求值。\n1 2 3 (buffer-name) (Buffer-file-name) 当我在 Info 中执行此操作时，对 (buffer-name) 求值返回的值是 *info*，而对 (buffer-file-name) 求值返回的值是 nil。\n另一方面，当我编写此文档时，对 (buffer-name) 求值返回的值是 \u0026ldquo;introduction.texinfo\u0026rdquo;，而对 (buffer-file-name) 求值返回的值是 \u0026ldquo;/gnu/work/intro/introduction.texinfo\u0026rdquo;。\n前者是缓冲区的名称，后者是文件的名称。在 Info 中，缓冲区名称是 *info*。Info 没有指向任何文件，所以对 (buffer-file-name) 求值的结果是 nil。符号 nil 源自拉丁语，意为“无”；在这种情况下，它意味着该缓冲区没有关联到任何文件。（在 Lisp 中，nil 也用于表示“假”，并且是空列表 () 的同义词。）\n当我在写作时，我的缓冲区名称是 \u0026ldquo;introduction.texinfo\u0026rdquo;。它所指向的文件名称是 \u0026ldquo;/gnu/work/intro/introduction.texinfo\u0026rdquo;。\n（在表达式中，括号告诉 Lisp 解释器将 buffer-name 和 buffer-file-name 作为函数处理；如果没有括号，解释器会尝试将这些符号作为变量进行求值。参见“变量”。）\n尽管文件和缓冲区之间存在区别，你常常会发现人们在指代缓冲区时说成文件，反之亦然。实际上，大多数人会说“我在编辑一个文件”，而不是说“我在编辑一个即将保存到文件的缓冲区”。从上下文中几乎总能清楚地知道人们的意思。然而，当处理计算机程序时，记住这种区别是很重要的，因为计算机不像人那么聪明。\n顺便提一下，“缓冲区”一词源自其作为缓冲垫的含义，可以减弱碰撞的冲击力。在早期的计算机中，缓冲区缓冲了文件与计算机中央处理单元之间的交互。存放文件的磁鼓或磁带和中央处理单元是两种截然不同的设备，它们以各自的速度间歇地工作。缓冲区使它们能够有效地协同工作。最终，缓冲区从一个中介、一个临时存储地，发展成为进行工作的地方。这种转变有点像一个小港口发展成一个大城市：起初它只是一个临时储存货物并等待装船的地方，后来它成为了一个商业和文化中心。\n并非所有缓冲区都与文件相关联。例如，*scratch* 缓冲区不访问任何文件。同样，*Help* 缓冲区也不与任何文件关联。\n在早期，如果你没有 ~/.emacs 文件并通过只输入 emacs 命令（而不是指定任何文件）启动一个 Emacs 会话， Emacs 会以 scratch 缓冲区可见的状态启动。如今，你会看到一个启动画面。你可以按照启动画面上建议的命令之一操作，访问一个文件，或者按 q 退出启动画面并进入 scratch 缓冲区。\n如果你切换到 scratch 缓冲区，输入 (buffer-name)，将光标放在它后面，然后按 C-x C-e 来对表达式求值。返回的名称 scratch 将出现在回显区域中。*scratch* 是缓冲区的名称。当你在 scratch 缓冲区中输入 (buffer-file-name)`并进行求值时，nil 将会出现在回显区域中，就像你在 Info 中求值 (buffer-file-name) 时一样。\n顺便说一下，如果你在 scratch 缓冲区中，希望表达式返回的值出现在 scratch 缓冲区本身而不是回显区域中，可以输入 C-u C-x C-e 而不是 C-x C-e。这会使返回的值出现在表达式之后。缓冲区看起来会像这样：\n1 (buffer-name)\u0026#34;*Scratch*\u0026#34; 你不能在 Info 中这样做，因为 Info 是只读的，它不允许你更改缓冲区的内容。但是，你可以在任何可以编辑的缓冲区中这样做；当你编写代码或文档（例如本书）时，这个功能非常有用。\n获取缓冲区 buffer-name 函数返回缓冲区的名称；要获取缓冲区本身，则需要使用另一个函数：current-buffer。如果你在代码中使用这个函数，你将得到的是缓冲区本身。\n名称和名称所指的对象或实体是不同的。你不是你的名字，你是一个被别人用名字称呼的人。如果你请求与乔治交谈，而有人递给你一张写有字母“G”、“e”、“o”、“r”、“g”和“e”的卡片，你可能会觉得好笑，但不会满意。你想交谈的不是名字，而是名字所指的人。缓冲区也是类似的：*scratch* 是 scratch 缓冲区的名称，但名称不是缓冲区本身。要获取缓冲区本身，你需要使用像 current-buffer 这样的函数。\n然而，这里有一个小小的复杂之处：如果你在表达式中单独对 current-buffer 求值（如我们在这里将做的那样），你看到的将是缓冲区名称的打印表示形式，而不是缓冲区的内容。 Emacs 之所以这样工作，有两个原因：缓冲区可能有成千上万行长，太长而不便于显示；并且另一个缓冲区可能具有相同的内容但名称不同，因此区分它们是很重要的。\n以下是包含该函数的一个表达式：\n1 (current-buffer) 如果你在 Emacs 的 Info 中以通常方式对这个表达式求值，#\u0026lt;buffer *info*\u0026gt; 将会出现在回显区域。这种特殊格式表明返回的是缓冲区本身，而不仅仅是其名称。\n顺便提一下，虽然你可以在程序中输入数字或符号，但你不能输入缓冲区的打印表示形式：获取缓冲区本身的唯一方法是使用像 current-buffer 这样的函数。\n一个相关的函数是 other-buffer。它返回最近选择的、当前缓冲区之外的另一个缓冲区，而不是它名称的打印表示形式。如果你最近在 scratch 缓冲区之间来回切换，other-buffer 将返回那个缓冲区。\n你可以通过对以下表达式求值看到这一点：\n1 (other-buffer) 你应该会看到 #\u0026lt;buffer *scratch*\u0026gt; 出现在回显区域中，或者看到你最近切换回的其他缓冲区的名称。\n切换缓冲区 other-buffer 函数在用作需要缓冲区作为参数的函数的参数时，实际上提供了一个缓冲区。我们可以通过使用 other-buffer 和 switch-to-buffer 来切换到不同的缓冲区，看到这一点。\n但首先，简要介绍一下 switch-to-buffer 函数。当你在 Info 和 scratch 缓冲区之间来回切换以求值 (buffer-name) 时，你很可能按下了 C-x b，然后在 minibuffer 中提示你输入要切换到的缓冲区名称时输入了 *scratch*。这些按键 C-x b 会使 Lisp 解释器评估交互函数 switch-to-buffer。正如我们之前所说，这就是 Emacs 的工作方式：不同的按键调用或运行不同的函数。例如，C-f 调用 forward-char，M-e 调用 `forward-sentence`，等等。\n通过在表达式中写出 switch-to-buffer 并提供一个要切换到的缓冲区，我们可以像 C-x b 那样切换缓冲区：\n1 (switch-to-buffer (other-buffer)) switch-to-buffer 符号是列表的第一个元素，因此 Lisp 解释器会将其视为一个函数，并执行与之相关的指令。但在此之前，解释器会注意到 other-buffer 在括号内，并先对该符号进行处理。 other-buffer 是该列表的第一个（在此情况下也是唯一的）元素，因此 Lisp 解释器会调用或运行该函数，它将返回另一个缓冲区。接下来，解释器运行 switch-to-buffer，并将返回的另一个缓冲区作为参数传递给它，这就是 Emacs 将要切换到的缓冲区。如果你在 Info 中阅读此内容，现在就试试。对这个表达式求值。（要返回原缓冲区，请键入 C-x b RET。）\n在本文件后续章节的编程示例中，你会更常看到 set-buffer 函数，而不是 switch-to-buffer。这是因为计算机程序和人类之间存在差异：人类有眼睛，期望在计算机终端上看到自己正在处理的缓冲区。这显而易见，几乎不言自明。然而，程序没有眼睛。当计算机程序处理缓冲区时，该缓冲区不需要在屏幕上可见。\nswitch-to-buffer 是为人类设计的，它做了两件事：它切换 Emacs 的注意力指向的缓冲区，并在窗口中将显示的缓冲区切换到新缓冲区。而 set-buffer 只做一件事：它将计算机程序的注意力切换到另一个缓冲区。屏幕上的缓冲区保持不变（当然，通常在命令运行完成之前那里不会发生任何变化）。\n另外，我们刚刚引入了另一个术语，即“调用”（call）。当你评估一个列表时，其中的第一个符号是一个函数，你就是在调用那个函数。这个术语的使用源于将函数视为一个可以为你做某事的实体——就像水管工是一个你可以打电话给他或她修理漏水的实体一样。\n缓冲区大小和点的位置 最后，让我们来看几个相对简单的函数：buffer-size、point、point-min 和 point-max。这些函数提供了有关缓冲区大小以及光标在其中位置的信息。\nbuffer-size 函数告诉你当前缓冲区的大小；即，该函数返回缓冲区中字符的数量。\n1 (buffer-size) 你可以通过将光标定位在表达式之后并按 C-x C-e 的通常方式来评估它。\n在 Emacs 中，光标的当前位置称为“点”（point）。表达式 (point) 返回一个数字，表示从缓冲区开头到光标所在位置的字符数量。\n你可以通过以通常方式评估以下表达式，查看当前缓冲区中点的字符计数：\n1 (point) 在我写下这些内容时，point 的值是 65724。point 函数在本书后面的一些示例中经常使用。\npoint 的值当然取决于它在缓冲区中的位置。如果你在这个位置对 point 求值，那么该数值会更大：\n1 (point) 对我来说，point 在此位置的值是 66043，这意味着两个表达式之间有 319 个字符（包括空格）。（毫无疑问，你会看到不同的数字，因为在我第一次 point 求值之后，我已经对内容进行了编辑。）\npoint-min 函数与 point 类似，但它返回当前缓冲区中 point 的最小允许值。这个值通常是 1，除非启用了“缩小”功能。（缩小是一种机制，通过它你可以限制自己或程序只在缓冲区的一部分进行操作。详见“缩小和扩展”部分。）同样，point-max 函数返回当前缓冲区中 point 的最大允许值。\n练习 找到一个你正在处理的文件，并移至其中间位置。找出该文件的缓冲区名称、文件名、长度以及你在文件中的位置。\n如何编写函数定义 当 Lisp 解释器对一个列表进行求值时，它会查看该列表的第一个符号是否附有一个函数定义；换句话说，即该符号是否指向一个函数定义。如果是，计算机就会执行定义中的指令。一个附有函数定义的符号简单地被称为“函数”（虽然严格来说，函数是定义本身，而符号是对它的引用）。\n关于原始函数的说明 所有函数都是用其他函数定义的，除了少数用C编程语言编写的原始函数。当你编写函数的定义时，你会在Emacs Lisp中编写它们，并使用其他函数作为构建块。你使用的一些函数本身会用Emacs Lisp编写（可能是你自己写的），而有些则是用C编写的原始函数。原始函数的用法和用Emacs Lisp编写的函数完全相同，并且表现也相似。它们之所以用C编写，是为了使GNU Emacs能够在任何具有足够性能并能运行C语言的计算机上轻松运行。\n让我再强调一下这一点：当你用Emacs Lisp编写代码时，你不会区分使用C语言编写的函数和使用Emacs Lisp编写的函数。区别是无关紧要的。我之所以提到这个区别，只是因为知道它是很有趣的。实际上，除非你深入研究，否则你不会知道一个已编写的函数是用Emacs Lisp编写的还是用C编写的。\ndefun 宏 在 Lisp 中，像 mark-whole-buffer 这样的符号有与之关联的代码，用来告诉计算机在调用该函数时该做什么。这段代码称为函数定义，它是通过符号 defun（\u0026ldquo;define function\u0026rdquo; 的缩写）开头的 Lisp 表达式创建的。\n在接下来的章节中，我们将查看来自 Emacs 源代码的函数定义，例如 mark-whole-buffer。在本节中，我们将描述一个简单的函数定义，以便你了解它的样子。这个函数定义使用了算术运算，因为这使得例子更简单。一些人不喜欢使用算术运算的例子；然而，如果你是这样的人，不必担心。在本介绍的其余部分，我们研究的代码几乎不涉及算术或数学。这些例子大多以某种方式涉及文本。\n一个函数定义在 defun 之后最多有五个部分：\n该函数定义应附加到的符号名称。 将传递给函数的参数列表。如果没有参数将传递给函数，这就是一个空列表 ()。 描述该函数的文档。（技术上是可选的，但强烈推荐。） 可选地，一个表达式，使函数可交互，这样你可以通过输入 M-x 然后函数名称，或者按下适当的键或组合键来使用它。 指示计算机该怎么做的代码：函数定义的主体。 将函数定义的五个部分想象成一个模板，其中每个部分都有一个插槽，这样会更有帮助。\n1 2 3 4 (defun function-name (arguments…) \u0026#34;optional-documentation…\u0026#34; (interactive argument-passing-info) ;可选的 body…) 作为示例，以下是一个将其参数乘以 7 的函数代码。（这个例子不是交互式的。关于如何使函数变得交互式，请参见“使函数变得交互式”的相关信息。）\n1 2 3 (defun multiply-by-seven (number) \u0026#34;Multiply NUMBER by seven.\u0026#34; (* 7 number)) 这个定义以一个括号和符号 defun 开头，接着是函数的名称。\n函数名称之后是一个包含将传递给函数的参数的列表，这个列表称为参数列表。在这个例子中，列表只有一个元素：符号 number。当函数被使用时，这个符号将绑定到作为函数参数的值。\n作为参数的名称，我本可以选择其他名字，而不是用 number 这个词。例如，我可以选择 multiplicand（被乘数）。我选择“number”这个词是因为它表明了这个位置的值应该是什么类型的；但我同样可以选择“multiplicand”这个词，来表示放在这个位置的值在函数工作中的作用。我甚至可以叫它 foogle，但那会是个糟糕的选择，因为它不会告诉人们它的含义。参数名称的选择取决于程序员，应该选择一个能使函数含义明确的名字。\n实际上，你可以为参数列表中的符号选择任何名称，甚至是某个其他函数中使用的符号名称：你在参数列表中使用的名称是该定义所私有的。在该定义中，这个名称指的是不同于函数定义外部任何使用相同名称的实体。假设你在家人中有一个昵称叫“Shorty”；当你的家人提到“Shorty”时，他们指的是你。但在你的家人之外，例如在电影中，“Shorty”这个名字可能指的是其他人。由于参数列表中的名称对于函数定义来说是私有的，你可以在函数体内更改该符号的值，而不会更改其在函数外部的值。其效果类似于 let 表达式产生的效果。（参见 let。）\n参数列表之后是描述函数的文档字符串。这是当你输入 C-h f 和函数名称时看到的内容。顺便提一下，当你编写这样的文档字符串时，应该使第一行成为一个完整的句子，因为有些命令（如 apropos）只打印多行文档字符串的第一行。此外，如果文档字符串有第二行，你不应该缩进它，因为在使用 C-h f (describe-function) 时，这样会显得不协调。虽然文档字符串是可选的，但它非常有用，几乎应该包含在你编写的每一个函数中。\n例子的第三行是函数定义的主体。（当然，大多数函数的定义比这个要长得多。）在这个函数中，主体是列表 (* 7 number)，它表示将 number 的值乘以 7。（在 Emacs Lisp 中，* 是乘法函数，就像 + 是加法函数一样。）\n当你使用 multiply-by-seven 函数时，参数 number 将被求值为你想要使用的实际数字。下面是一个展示如何使用 multiply-by-seven 的例子；不过，暂时不要尝试对其求值！\n1 (multiply-by-seven 3) 在实际使用该函数时，在下一节的函数定义中指定的符号 number 被绑定到值 3。请注意，虽然在函数定义中 number 在括号内，但传递给 multiply-by-seven 函数的参数不是在括号内。括号在函数定义中被写出是为了让计算机能识别参数列表的结束位置和函数定义其余部分的开始位置。\n如果你对这个例子求值，你很可能会得到一个错误消息。（不妨试试看！）这是因为我们已经编写了函数定义，但还没有告诉计算机这个定义——我们还没有在 Emacs 中加载函数定义。安装函数的过程就是告诉 Lisp 解释器函数的定义。安装的过程将在下一节中介绍。\n安装函数定义 如果你正在 Emacs 的 Info 模式中阅读本文，可以通过先对函数定义求值，然后再对 (multiply-by-seven 3) 求值来试用 multiply-by-seven 函数。以下是函数定义的副本。将光标放在函数定义的最后一个括号之后，然后按 C-x C-e。这样做时，multiply-by-seven 会出现在回显区域。（这意味着，当对函数定义求值时，它返回的值是被定义的函数的名称。）同时，这个操作会安装函数定义。\n1 2 3 (defun multiply-by-seven (number) \u0026#34;Multiply NUMBER by seven.\u0026#34; (* 7 number)) 通过对这个 defun 求值，你刚刚在 Emacs 中安装了 multiply-by-seven。现在，这个函数和 forward-word 或任何其他你使用的编辑函数一样，已经成为 Emacs 的一部分了。（multiply-by-seven 将一直保持安装状态，直到你退出 Emacs。要了解如何在每次启动 Emacs 时自动重新加载代码，请参阅“永久安装代码”。）\n安装的效果 你可以通过对以下示例求值来查看安装 multiply-by-seven 的效果。将光标放在以下表达式之后，然后按 C-x C-e。数字 21 将出现在回显区域。\n1 (Multiply-by-seven 3) 如果你愿意，可以通过输入 C-h f (describe-function)，然后输入函数名 multiply-by-seven 来查看该函数的文档。这样做时，屏幕上会出现一个 Help 窗口，上面显示：\n1 2 3 4 5 multiply-by-seven is a Lisp function. (multiply-by-seven NUMBER) Multiply NUMBER by seven. （要返回屏幕上的单窗口显示，输入 C-x 1。）\n修改函数定义 如果你想更改 multiply-by-seven 的代码，只需重写它即可。要用新版本替换旧版本，只需再次对函数定义求值。这就是在 Emacs 中修改代码的方式，非常简单。\n例如，你可以将 multiply-by-seven 函数更改为将数字自身相加七次，而不是将数字乘以七。这样做会通过不同的方式产生相同的答案。同时，我们还会在代码中添加一条注释；注释是 Lisp 解释器忽略的文本，但可能对人类读者有用或有启发。注释指出这是第二个版本。\n1 2 3 (defun multiply-by-seven (number) ; 第二个版本。 \u0026#34;Multiply NUMBER by seven.\u0026#34; (+ number number number number number number number)) 注释位于分号 ; 之后。在 Lisp 中，分号后面的一行内容都是注释。行尾就是注释的结束。如果要将注释扩展到两行或更多行，每行都要以分号开头。\n关于注释的更多信息，请参见《GNU Emacs Lisp参考手册》中的“编写 .emacs 文件”和“注释”部分。\n你可以通过对这个版本的 multiply-by-seven 函数求值来安装它，方法与对第一个函数求值的方式相同：将光标放在最后一个括号之后，然后按 C-x C-e。\n总之，这就是在 Emacs Lisp 中编写代码的方法：编写一个函数，安装它，测试它，然后进行修复或改进并再次安装。\n使函数具有交互性 你可以通过在文档之后紧接着放置一个以特殊形式 interactive 开头的列表来使一个函数具有交互性。用户可以通过键入 M-x 然后输入函数名称来调用一个交互函数；或者通过键入与其绑定的快捷键来调用，例如，键入 C-n 调用 next-line 或 C-x h 调用 mark-whole-buffer。\n有趣的是，当你以交互方式调用一个交互函数时，返回的值不会自动显示在回显区域。这是因为你通常调用一个交互函数是为了它的副作用，比如向前移动一个单词或一行，而不是为了它的返回值。如果每次按键时返回的值都显示在回显区域，那将会非常分散注意力。\n交互式的 multiply-by-seven：概述 通过创建一个交互版本的 multiply-by-seven 函数，可以说明特殊形式 interactive 的使用方法，以及如何在回显区显示一个值。\n代码如下：\n1 2 3 4 (defun multiply-by-seven (number) ; 交互版本。 \u0026#34;将 NUMBER 乘以七。\u0026#34; (interactive \u0026#34;p\u0026#34;) (message \u0026#34;结果是 %d\u0026#34; (* 7 number))) 您可以通过将光标放置在代码之后并输入 C-x C-e 来安装此代码。函数名称将显示在回显区中。然后，您可以输入 C-u 和一个数字，再输入 M-x multiply-by-seven 并按下 RET 键来使用该代码。短语 “The result is \u0026hellip;”（结果是\u0026hellip;）以及相应的乘积将出现在回显区中。\n更一般地说，您可以通过以下两种方式调用这样的函数：\n输入包含要传递数字的前缀参数，然后输入 M-x 和函数名，例如 C-u 3 M-x forward-sentence 输入函数绑定的按键或按键组合，例如 C-u 3 M-e。 以上两个示例的效果相同，都是将光标向前移动三个句子。（由于 multiply-by-seven 没有绑定到按键，因此不能用作按键绑定的示例。）\n（请参阅 “按键绑定”，了解如何将命令绑定到按键。）\n可以通过按下 META 键然后输入一个数字（例如 M-3 M-e），或者按下 C-u 然后输入一个数字（例如 C-u 3 M-e），将前缀参数传递给交互式函数（如果只输入 C-u 而没有数字，则默认值为 4）。\n一个交互的乘以七函数 让我们看看特殊形式 interactive 的用法，然后看一下 multiply-by-seven 函数的交互版本中的 message 函数。你可能记得函数定义如下所示：\n1 2 3 4 (defun multiply-by-seven (number) ; 交互版本。 \u0026#34;将 NUMBER 乘以七。\u0026#34; (interactive \u0026#34;p\u0026#34;) (message \u0026#34;结果是 %d\u0026#34; (* 7 number))) 在这个函数中，表达式 (interactive \u0026ldquo;p\u0026rdquo;) 是一个包含两个元素的列表。\u0026ldquo;p\u0026rdquo; 告诉 Emacs 将前缀参数传递给函数，并将其值用于函数的参数。\n这个参数将是一个数字。这意味着符号 number 将在以下这一行中绑定到一个数字：\n1 (message \u0026#34;结果是 %d\u0026#34; (* 7 number)) 例如，如果你的前缀参数是 5，Lisp 解释器将像下面这样计算这一行：\n1 (message \u0026#34;结果是 %d\u0026#34; (* 7 5)) （如果你在 GNU Emacs 中阅读此内容，可以自己计算这个表达式。）首先，解释器将计算内部列表，即 (* 7 5)。这会返回一个值 35。接着，它将计算外部列表，把列表的第二个及后续元素的值传递给 message 函数。\n正如我们所见，message 是一个 Emacs Lisp 函数，专为向用户发送单行消息而设计。（请参见 message 函数。）总的来说，message 函数会将其第一个参数按原样打印在回显区，除了 %d 或 %s 的出现（以及其他我们尚未提到的各种 % 开头的序列）。当它遇到一个控制序列时，函数会查看第二个或后续参数，并在字符串中控制序列所在的位置打印该参数的值。\n在交互的 multiply-by-seven 函数中，控制字符串是 %d，它要求一个数字，而通过计算 (* 7 5) 返回的值是数字 35。因此，数字 35 会被打印在 %d 的位置，消息内容为 “The result is 35”。\n（注意，当你调用 multiply-by-seven 函数时，消息是直接打印的，没有引号；但当你调用 message 函数时，文本会以双引号打印。这是因为当你计算一个其第一个元素是 message 的表达式时，message 返回的值会显示在回显区；但当 message 嵌入在函数中时，它作为一个副作用打印文本而不带引号。）\ninteractive 的不同选项 在示例中，multiply-by-seven 使用 \u0026ldquo;p\u0026rdquo; 作为 interactive 的参数。这个参数告诉 Emacs 将你输入的 C-u 后跟一个数字，或 META 后跟一个数字解释为将该数字作为参数传递给函数的命令。 Emacs 预定义了超过二十个字符用于 interactive。在几乎每种情况下，这些选项中的一个将使你能够以交互方式向函数传递正确的信息。（请参阅《GNU Emacs Lisp 参考手册》中的 \u0026ldquo;Code Characters for interactive\u0026rdquo;。）\n考虑函数 zap-to-char。它的 interactive 表达式是：\n1 (interactive \u0026#34;p\\ncZap to char: \u0026#34;) interactive 参数的第一部分是你已经熟悉的 p。该参数告诉 Emacs 将前缀解释为要传递给函数的数字。你可以通过输入 C-u 后跟一个数字或输入 META 后跟一个数字来指定前缀。前缀是指定字符的数量。因此，如果你的前缀是 3，指定的字符是 x，那么你将删除直到第三个 x（包括它）之前的所有文本。如果不设置前缀，则删除直到指定字符（包括它）之前的所有文本。\nc 告诉函数要删除的字符的名称。\n更正式地说，一个具有两个或多个参数的函数可以通过将部分添加到 interactive 后面的字符串中，将信息传递给每个参数。当你这样做时，信息按照在 interactive 列表中指定的顺序传递给每个参数。在字符串中，每个部分由 \\n（换行符）分隔开。例如，你可以在 p 后面加上一个 \\n 和 cZap to char: 。这会使 Emacs 传递前缀参数的值（如果有）和字符。\n在这种情况下，函数定义如下所示，其中 arg 和 char 是 interactive 绑定前缀参数和指定字符的符号：\n1 2 3 4 5 (defun name-of-function (arg char) \u0026#34;文档……\u0026#34; (interactive \u0026#34;p\\ncZap to char: \u0026#34;) 函数主体…… ) （在提示符中的冒号后加上空格，使提示看起来更好。参见 copy-to-buffer 的定义示例。）\n当一个函数不需要参数时，interactive 也不需要参数。这样的函数包含一个简单的表达式 (interactive)。 mark-whole-buffer 函数就是这样的例子。\n另外，如果这些特殊的字母代码不适合你的应用，你可以将自己的参数作为列表传递给 interactive。\n参见 append-to-buffer 的定义示例。有关此技术的更完整解释，请参阅《GNU Emacs Lisp 参考手册》中的 \u0026ldquo;Using Interactive\u0026rdquo;。\n永久安装代码 当你通过计算函数定义来安装它时，该函数将一直保持安装状态，直到你退出 Emacs。下次你启动一个新的 Emacs 会话时，该函数将不会被安装，除非你再次计算函数定义。\n在某个时候，你可能希望每次启动 Emacs 新会话时自动安装代码。你可以通过以下几种方法实现：\n如果你有仅供自己使用的代码，可以将函数定义的代码放在 .emacs 初始化文件中。当你启动 Emacs 时，.emacs 文件会自动计算，文件中的所有函数定义都会被安装。参见 \u0026ldquo;Your .emacs File\u0026rdquo;。 或者，你可以将需要安装的函数定义放在一个或多个文件中，并使用 load 函数让 Emacs 计算这些文件，从而安装其中的每个函数。参见 \u0026ldquo;Loading Files\u0026rdquo;。 第三，如果你有供整个站点使用的代码，通常将其放在一个名为 site-init.el 的文件中，该文件在构建 Emacs 时被加载。这使得所有使用你的机器的人都可以使用这些代码。（参见 Emacs 发行版中的 INSTALL 文件。） 最后，如果你有代码希望所有 Emacs 用户都能使用，你可以将其发布在计算机网络上，或将副本发送给自由软件基金会。（当你这样做时，请将代码及其文档在允许他人运行、复制、研究、修改和再分发代码的许可证下发布，并保护自己不被剥夺你的工作成果。）如果你将代码副本发送给自由软件基金会，并正确保护自己和他人，这些代码可能会被包含在 Emacs 的下一个版本中。在很大程度上，Emacs 在过去的几年中就是通过这样的捐赠逐步扩展的。\nlet let 表达式是 Lisp 中的一种特殊形式，在大多数函数定义中你都需要使用它。\nlet 用于将一个符号附加或绑定到一个值上，这样 Lisp 解释器就不会将变量与另一个不属于该函数的同名变量混淆。\n要理解为什么需要 let 这种特殊形式，可以考虑你拥有一所房子的情况，你通常称之为“the house”，例如在这句话中：“The house needs painting.” 如果你在拜访朋友时，你的主人提到“the house”，他很可能指的是他自己的房子，而不是你的，也就是说，是指另一所房子。\n如果你的朋友指的是他自己的房子，而你以为他指的是你的房子，这就可能引发混淆。在 Lisp 中也可能发生同样的情况：如果一个函数内部使用的变量与另一个函数内部使用的变量同名，而这两个变量并不打算表示相同的值，那么可能会导致混淆。let 特殊形式可以防止这种混淆。\nlet 防止混淆 let 特殊形式可以防止混淆。let 为局部变量创建一个名称，遮蔽在 let 表达式之外对相同名称的任何使用（在计算机科学术语中，这称为“绑定变量”）。这就像理解在你主人的家中，每当他提到“the house”时，他指的是他的房子，而不是你的房子。（用于命名函数参数的符号也以完全相同的方式绑定为局部变量。参见 defun 宏。）\n另一种理解 let 的方式是，它在你的代码中定义了一个特殊的区域：在 let 表达式的主体内部，你命名的变量有其自己的局部意义。在 let 主体之外，它们有其他的意义（或者可能根本没有定义）。这意味着在 let 主体内部，为 let 表达式命名的变量调用 setq 会设置该名称的局部变量的值。然而，在 let 主体之外（例如，在调用另一个地方定义的函数时），为 let 表达式命名的变量调用 setq 不会影响该局部变量。\nlet 可以一次创建多个变量。同时，let 为其创建的每个变量赋予一个初始值，该初始值可以是你指定的值或 nil。（在术语中，这称为将变量绑定到一个值。）在 let 创建并绑定了变量之后，它会执行 let 主体中的代码，并将主体中最后一个表达式的值作为整个 let 表达式的值返回。（“执行”是一个术语，意味着计算一个列表；它来自该词的含义“付诸实际效果”（《牛津英语词典》）。因为你计算一个表达式来执行一个动作，“执行”已经演变为“计算”的同义词。）\n","date":"2024-08-18T00:00:00Z","permalink":"https://JanSky520.github.io/p/elisp%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97/","title":"elisp快速指南"},{"content":"简介 Org 是一种使用快速有效的纯文本系统记笔记、维护待办事项列表和进行项目规划的模式。它也是一个创作和发布系统，支持使用源代码进行文学编程和可重复的研究。\n本文档是 Org 手册的精简版。它包含所有基本功能和命令，以及自定义的重要提示。它适用于那些因为篇幅过大而不愿阅读 200 页手册的初学者。\n安装 重要提示：如果您使用的 Org 版本是 Emacs 发行版的一部分，请跳过此部分并直接转到激活。将从网上下载的 org 模块添加到 Emacs 配置中以激活\n1 (add-to-list \u0026#39;load-path \u0026#34;~/path/to/orgdir/lisp\u0026#34;) 激活 将以下几行添加到您的 Emacs 初始化文件中，为三个命令定义全局键，这些键在任何 Emacs 缓冲区（而不仅仅是 Org 缓冲区）中都很有用。可根据自身习惯自行选择合适的键。\n1 2 3 (global-set-key (kbd \u0026#34;C-c l\u0026#34;) #\u0026#39;org-store-link) (global-set-key (kbd \u0026#34;C-c a\u0026#34;) #\u0026#39;org-agenda) (global-set-key (kbd \u0026#34;C-c c\u0026#34;) #\u0026#39;org-capture) 反馈 如果您发现 Org 存在问题，或者您有疑问、评论或想法，请发送邮件至 Org 邮件列表 mailto:emacs-orgmode@gnu.org。有关如何提交错误报告的信息，请参阅主手册。\n文档结构 Org 是一个大纲工具。大纲允许将文档组织成层次结构，对于我们来说，这是对笔记和想法的最佳表示。通过折叠可以快速浏览文档的结构，即隐藏文档的大部分内容以仅显示一般文档结构和当前正在处理的部分。 Org 通过将整个显示和隐藏功能通过 TAB 键与 org-cycle 绑定的单个命令，大大简化了整体的使用。\n标题 标题定义了大纲树的结构。Org 中的标题从左边距开始，以一个或多个星号开头，后跟一个空格。例如：\n1 2 3 4 5 6 7 * 顶级标题 ** 第二级 *** 第三级 一些文本 *** 第三级 更多文本 * 另一个顶级标题 请注意，命名的标题 org-footnote-section 默认为 \u0026lsquo;脚注\u0026rsquo;，被视为特殊。具有此标题的子树将被导出函数默认忽略。\n有些人觉得很多星星太嘈杂，他们更喜欢轮廓上有空白，后面跟着一颗星星作为标题开头。请参阅杂项，了解实现此目的的设置。\n可见的循环 TAB 功能可在缓冲区中隐藏文本。 Org 模式使用两个命令，分别绑定到 TAB 和 S-TAB（org-cycle 和 org-shifttab），以改变缓冲区中的可见性。\nTAB (org-cycle) 子树循环：在当前子树的状态之间轮换。 S-TAB (org-global-cycle) | C-u TAB (org-cycle) 全局循环：在整个缓冲区的状态之间轮换 当 Emacs 首次访问 Org 文件时，全局状态设置为概览，默认不隐藏文档内容。可以通过变量 org-startup-folded 进行配置，或者通过在文件中添加 STARTUP 关键字来进行文件级别的配置。关键字可以是 overview(隐藏全部内容)、content(仅显示标题包括子标题)、showall(文档内容全部显示)、showeverything 或 show\u0026lt;n\u0026gt;levels（n = 2..5），例如：\n1 #+STARTUP: content 移动 以下命令用于跳转到缓冲区中的其他标题。\nC-c C-n (org-next-visible-heading) 跳转到下一个标题。 C-c C-p (org-previous-visible-heading) 跳转到上一个标题。 C-c C-f (org-backward-heading-same-level) 跳转到下一个同级标题。 C-c C-b (outline-backward-same-level) 跳转到上一个同级标题。 C-c C-u (outline-up-heading) 向上跳转到更高层级的标题。 结构编辑 M-RET (org-meta-return) 插入与当前级别相同的新标题。如果光标在普通列表项中，则创建一个新项（参见普通列表）。当在行中间使用此命令时，当前行会被拆分，剩余部分成为新的标题。 M-S-RET (org-insert-todo-heading) 在当前标题级别插入新的 TODO 项目。 TAB (org-cycle) 在新的空条目中，TAB 循环切换合理的级别。 M-LEFT (org-metaleft) | M-RIGHT (org-metaright) 将当前标题提升或降低一级。 M-UP (org-move-subtree-up) | M-DOWN (org-move-subtree-down) 将子树上移或下移，即与同级的前一个或下一个子树交换位置。 C-c C-w (org-refile) 将条目或区域重新归档到不同的位置。参见“重新归档和复制”。 C-x n s (org-narrow-to-subtree) | C-x n w (widen) 将缓冲区限制到当前子树，然后再扩大它。 当有一个活动区域（瞬态标记模式）时，提升和降级操作将作用于该区域内的所有标题。\n稀疏树 Org mode 的一个重要功能是能够为大纲树中的选定信息构建稀疏树，使整个文档尽可能地折叠。同时将选定的信息及其上方的标题结构显示出来。只需尝试一下，你就会立即明白它是如何工作的。\nOrg mode 包含几个创建这种树的命令，所有这些命令可以通过调度器访问：\nC-c / (org-sparse-tree) 这将提示你输入一个额外的键来选择一个创建稀疏树的命令。 C-c / r (org-occur) Occur。提示输入一个正则表达式，并显示一个包含所有匹配项的稀疏树。每个匹配项也会被高亮显示；按下 C-c C-c 可以取消高亮显示。\n其他稀疏树命令根据 TODO 关键字、标签或属性来选择标题，这些将在本手册的后续部分讨论。 普通列表 在大纲树的条目中，手工格式化的列表可以提供额外的结构。它们还提供了一种创建复选框列表的方式（参见复选框）。 Org 支持编辑这些列表，并且每个导出器（参见导出）都可以解析和格式化它们。\nOrg 支持有序列表、无序列表和描述列表。\n无序列表项以‘-’，‘+’，或‘*’作为项目符号开始。\n有序列表项以‘1.’ 或 ‘1)’ 开始。\n描述列表使用‘::’来分隔术语和描述。\n属于同一列表的项目必须在第一行具有相同的缩进。一个项目在下一个与其项目符号/编号对齐的行或更少的缩进之前结束。一个列表在所有项目都闭合后结束，或在两个空行之前结束。示例如下：\n1 2 3 4 5 6 7 8 9 * 《魔戒》 我最喜欢的场景是（按以下顺序） 1. Rohirrim 的攻击 2. Eowyn 与巫王的战斗 + 这已经是我在书中的最喜欢的场景 + 我非常喜欢 Miranda Otto。 这部电影中的重要演员有： - Elijah Wood :: 他饰演弗罗多 - Sean Astin :: 他饰演山姆，弗罗多的朋友。 当光标位于项目的第一行（带有项目符号或编号的行）时，以下命令会对项目执行操作。\nTAB (org-cycle) 项目可以像标题级别一样折叠。 M-RET (org-insert-heading) 在当前级别插入新项目。使用前缀参数时，强制插入新标题（请参见结构编辑）。 M-S-RET (org-insert-todo-heading) 插入一个带有复选框的新项目（请参见复选框）。 M-UP (org-move-item-up) | M-DOWN (org-move-item-down) 将当前项目（包括子项目）上移/下移（与相同缩进的前一个/下一个项目交换）。如果列表是有序的，自动重新编号。 M-LEFT (org-do-promote) | M-RIGHT (org-do-demote) 减少/增加项目的缩进，不影响子项目。 M-S-LEFT (org-promote-subtree) | M-S-RIGHT (org-demote-subtree) 减少/增加当前项目及其子项目的缩进。 C-c C-c (org-toggle-checkbox) 如果项目行中有复选框（参见复选框），切换复选框的状态。同时验证整个列表中的项目符号和缩进一致性。 C-c - (org-cycle-list-bullet) 在整个列表级别之间循环不同的项目符号（‘-’，‘+’，‘*’，‘1.’，‘1)’）。 表格 Org 配备了一个快速直观的表格编辑器。与 Emacs Calc 包（参见 GNU Emacs 计算器手册）结合使用时，支持类似电子表格的计算功能。 Org 使得以纯 ASCII 格式化表格变得简单。任何以 ‘|’ 作为第一个非空白字符的行都被视为表格的一部分。‘|’ 也用作列分隔符。一个表格可能看起来像这样：\n1 2 3 | Name | Phone | Age | | Peter | 1234 | 17 | | Anna | 4321 | 25 | 每次在表格内按 TAB、RET 或 C-c C-c 时，表格会自动重新对齐。 TAB 还会移动到下一个字段（RET 移动到下一行），并在表格末尾或水平线之前创建新的表格行。表格的缩进由第一行设置。任何以 ‘|-’ 开头的行都被视为水平分隔线，并将在下次对齐时扩展以覆盖整个表格宽度。因此，要创建上述表格，你只需输入\n1 2 | Name | Phone | Age | |- 然后按 TAB 来对齐表格并开始填写字段。更快的方法是输入 ‘|Name|Phone|Age’，然后按 C-c RET。在字段中输入文本时，Org 以特殊方式处理 DEL、Backspace 和所有字符键，以避免插入和删除操作导致其他字段发生位移。此外，当在使用 TAB、S-TAB 或 RET 将光标移动到新字段后立即开始输入时，该字段会自动变为空白。\n创建和转换 C-c | (org-table-create-or-convert-from-region) 将活动区域转换为表格。如果每行都包含至少一个 TAB 字符，函数会假定这些内容是以 TAB 分隔的。如果每行都包含逗号，则假定为逗号分隔值（CSV）。如果都不符合，行则会在空白处拆分为字段。如果没有活动区域，此命令将创建一个空的 Org 表格。但更简单的方法是直接开始输入，比如输入 | Name | Phone | Age RET | - TAB。 重新对齐和字段移动 C-c C-c (org-table-align): 重新对齐表格，但不移动光标。 TAB (org-table-next-field): 重新对齐表格，并移动到下一个字段（单元格）。如果在行末，会创建一个新行（如果需要）。 S-TAB (org-table-previous-field): 重新对齐表格，并移动到上一个字段。 RET (org-table-next-row): 重新对齐表格，并移动到下一行。如果需要，会创建一个新行。 S-UP (org-table-move-cell-up): 将当前单元格向上移动，通过与上方的单元格交换位置。 S-DOWN (org-table-move-cell-down): 将当前单元格向下移动，通过与下方的单元格交换位置。 S-LEFT (org-table-move-cell-left): 将当前单元格向左移动，通过与左侧的单元格交换位置。 S-RIGHT (org-table-move-cell-right): 将当前单元格向右移动，通过与右侧的单元格交换位置。 列和行编辑 M-LEFT (org-table-move-column-left): 将当前列向左移动。 M-RIGHT (org-table-move-column-right): 将当前列向右移动。 M-S-LEFT (org-table-delete-column): 删除当前列。 M-S-RIGHT (org-table-insert-column): 在光标位置左侧插入一个新列。 M-UP (org-table-move-row-up): 将当前行向上移动。 M-DOWN (org-table-move-row-down): 将当前行向下移动。 M-S-UP (org-table-kill-row): 删除当前行或水平线。 M-S-DOWN (org-table-insert-row): 在当前行上方插入一行。带有前缀参数时，将在当前行下方创建一行。 C-c - (org-table-insert-hline): 在当前行下方插入一条水平线。带有前缀参数时，将在当前行上方插入一条水平线。 C-c RET (org-table-hline-and-move): 在当前行下方插入一条水平线，并将光标移动到该行下方的行中。 C-c ^ (org-table-sort-lines): 对表格中的行进行排序。 在指定区域内对表格行进行排序。光标位置指示用于排序的列，排序的范围是最接近的水平分隔线之间的行，或者是整个表格。\n超链接 类似于 HTML，Org 也支持在文件内部、外部文件、Usenet 文章、电子邮件等地方使用链接。 Org 可以识别普通的 URI，通常用尖括号括起来，并将其激活为可点击的链接。不过，一般的链接格式如下：\n1 [[LINK][DESCRIPTION]] 或者：\n1 [[LINK]] 处理链接 Org 提供了多种方法来创建链接、将其插入到 Org 文件中，以及跟随链接。主要功能是 org-store-link，可以通过 M-x org-store-link 调用。由于其重要性，我们建议将其绑定到一个广泛使用的快捷键（参见激活）。该功能会存储当前位置的链接，以便稍后插入到 Org 缓冲区中（见下文）。在 Org 缓冲区中，以下命令用于创建、导航或更一般地操作链接： C-c C-l (org-insert-link)：插入一个链接。该命令会提示输入要插入的链接。你可以直接输入一个链接，也可以使用历史记录键 UP 和 DOWN 访问已存储的链接。系统会提示你输入链接的描述部分。 当以 C-u 前缀参数调用时，将使用文件名补全功能来链接到文件。 C-c C-l（当光标位于现有链接上） (org-insert-link)：当光标位于现有链接上时，C-c C-l 允许你编辑链接和描述部分。 C-c C-o (open-link-at-point)：打开光标所在位置的链接。 C-c \u0026amp; (org-mark-ring-goto)：跳转回记录的位置。位置由内部链接的命令记录，并由 C-c % 记录。多次连续使用该命令可以在之前记录的位置环中循环移动。 TODO 项目 Org 模式并不要求 TODO 列表必须存在于单独的文档中。相反，TODO 项目可以作为笔记文件的一部分，因为 TODO 项目通常是在记录笔记时产生的！在 Org 模式中，只需将树形结构中的任何条目标记为 TODO 项目即可。这样，信息不会重复，TODO 项目也保留在其产生的上下文中。\nOrg 模式提供了多种方法来概览你需要完成的所有事项，这些事项可以从多个文件中收集。\n基本 TODO 功能 任何标题如果以 TODO 去表示，例如：\n1 *** TODO 写信给 Sam Fortune 与 TODO 条目一起使用的最重要的命令是：\nC-c C-t（org-todo）\n循环 TODO 状态 S-RIGHT（org-shiftright） S-LEFT（org-shiftleft）\n选择下一个/前一个 TODO 状态，类似于循环。 C-c / t（org-show-todo-tree）\n在稀疏树中查看 TODO 项（参见稀疏树）。折叠整个缓冲区，但显示所有 TODO 项（未完成状态）及其上方的标题层次结构。 M-x org-agenda t（org-todo-list）\n显示全局 TODO 列表。将所有议程文件（参见议程视图）中的 TODO 项（未完成状态）收集到单个缓冲区中。有关更多信息，请参阅全局 TODO 列表。 S-M-RET（org-insert-todo-heading）\n在当前 TODO 条目下方插入新的 TODO 条目。 多状态工作流 您可以使用 TODO 关键字来指示连续的工作进度状态：\n1 2 (setq org-todo-keywords \u0026#39;((sequence \u0026#34;TODO\u0026#34; \u0026#34;FEEDBACK\u0026#34; \u0026#34;VERIFY\u0026#34; \u0026#34;|\u0026#34; \u0026#34;DONE\u0026#34; \u0026#34;DELEGATED\u0026#34;))) 垂直分隔符将“TODO”关键字（需要采取行动的状态）与“DONE”状态（不需要进一步行动的状态）分开。如果不提供分隔符，则最后一个状态会被用作“DONE”状态。在这种设置下，命令 C-c C-t 会将一个条目从“TODO”状态切换到“FEEDBACK”，接着是“VERIFY”，最后到“DONE”和“DELEGATED”。\n有时你可能希望同时使用不同的 TODO 关键字集。例如，你可能希望拥有基本的“TODO=/=DONE”设置，同时也有一个用于修复 bug 的工作流程。那么你的设置可能会像这样：\n1 2 3 (setq org-todo-keywords \u0026#39;((sequence \u0026#34;TODO(t)\u0026#34; \u0026#34;|\u0026#34; \u0026#34;DONE(d)\u0026#34;) (sequence \u0026#34;REPORT(r)\u0026#34; \u0026#34;BUG(b)\u0026#34; \u0026#34;KNOWNCAUSE(k)\u0026#34; \u0026#34;|\u0026#34; \u0026#34;FIXED(f)\u0026#34;))) 关键词应该都不同，这有助于 Org 模式跟踪在给定条目中应使用哪个子序列。示例还展示了如何通过在每个关键词后添加括号中的字母来定义用于快速访问特定状态的键——在按下 C-c C-t 后，系统会提示输入键。要定义仅在单个文件中有效的 TODO 关键词，请在文件中的任何位置使用以下文本。\n1 2 3 #+TODO: TODO(t) | DONE(d) #+TODO: REPORT(r) BUG(b) KNOWNCAUSE(k) | FIXED(f) #+TODO: | CANCELED(c) 在更改了其中一行之后，请将光标保持在该行上，然后使用 C-c C-c 以使 Org 模式识别这些更改。\n进度日志 要在更改 TODO 状态时记录时间戳和备注，可以使用带有前缀参数的 org-todo 命令。\nC-u C-c C-t（org-todo）\n提示输入备注并记录 TODO 状态更改的时间。 Org 模式还可以在将 TODO 项标记为 DONE 时自动记录时间戳，并可以选择性地添加备注，甚至可以在每次更改 TODO 项状态时都进行记录。这个系统高度可配置，设置可以按关键字定制，并且可以在文件或子树级别进行本地化。有关如何记录任务的工作时间的信息，请参阅“记录工作时间”。\n关闭项目 最基本的记录方式是跟踪某个 TODO 项被标记为完成的时间。这可以通过以下设置实现： 1 (setq org-log-done \u0026#39;time) 这样，每次将条目从 TODO（未完成）状态转换为任何 DONE 状态时，标题下方会插入一行 CLOSED: [时间戳]。如果你还想记录备注，可以使用：\n1 (setq org-log-done \u0026#39;note) 此时系统会提示你输入备注，并将该备注以 Closing Note 作为标题存储在条目下方。\n追踪 TODO 状态变更 您可能希望追踪 TODO 状态的变化。您可以选择仅记录时间戳，或者记录带有时间戳的变更说明。这些记录会在标题后插入为项目化列表。当记录很多笔记时，您可能希望将这些笔记移入一个抽屉中。可以通过自定义变量 org-log-into-drawer 来实现这一行为。对于状态日志记录，Org 模式要求按关键字配置。这是通过在每个关键字后面添加特殊标记 !（用于时间戳）和 @（用于说明）来实现的。例如： 1 #+TODO: TODO(t) WAIT(w@/!) | DONE(d!) CANCELED(c@) 这段配置定义了 TODO 关键字和快速访问键，并且要求在条目状态设置为 ‘DONE’ 时记录时间，切换到 ‘WAIT’ 或 ‘CANCELED’ 时记录说明。当设置 org-todo-keywords 时，使用相同的语法也可以实现类似效果。 优先级 如果你大量使用 Org mode，你可能会有足够多的 TODO 项目，这时给它们排序就变得有意义了。可以通过在 TODO 项目的标题中添加优先级标记来进行排序，如下所示：\n1 *** TODO [#A] Write letter to Sam Fortune Org mode 支持三种优先级：‘A’，‘B’，和‘C’。‘A’是最高优先级，‘B’是默认优先级，如果没有指定则使用‘B’。优先级只在日程表中起作用。\nC-c , (org-priority) 设置当前标题的优先级。按 A、B 或 C 选择优先级，按 SPC 移除标记。 S-UP (org-priority-up) S-DOWN (org-priority-down) 增加/减少当前标题的优先级。 将任务拆分为子任务 通常建议将大型任务拆分为更小、更易于管理的子任务。你可以通过在 TODO 项目下创建一个大纲树来完成这项工作，在树下列出详细的子任务。为了保持对已完成子任务比例的概览，可以在标题的任何位置插入 ‘[/]’ 或 ‘[%]’。这些标记会在子任务的 TODO 状态发生变化时更新，或者在按下 C-c C-c 时更新。例如：\n1 2 3 4 5 6 * Organize Party [33%] ** TODO Call people [1/2] *** TODO Peter *** DONE Sarah ** TODO Buy food ** DONE Talk to neighbor 复选框 在普通列表中的每一项都可以通过在项目前添加字符串 ‘[ ]’ 来变成复选框。复选框不会被纳入全局 TODO 列表，因此它们非常适合将一个任务拆分成多个简单步骤。以下是一个复选框列表的示例：\n1 2 3 4 5 * TODO Organize party [2/4] - [-] call people [1/2] - [ ] Peter - [X] Sarah - [X] order food 复选框的层级结构 复选框具有层级结构，因此如果一个复选框项下有子项，这些子项也是复选框，当你切换子项的状态时，父项的复选框会反映出子项的状态：即是否所有子项、一些子项或没有子项被选中。以下命令适用于复选框：\nC-c C-c, C-u C-c C-c (org-toggle-checkbox) 切换复选框的状态，或者使用前缀参数切换当前复选框项的存在。\nM-S-RET (org-insert-todo-heading) 在普通列表项中插入一个带复选框的新项。这只在光标已经位于普通列表项时有效（见“普通列表”）。\n标签 一个有效的实现标签和上下文以便交叉关联信息的方法是将标签分配给标题。Org mode 对标签提供了广泛的支持。每个标题都可以包含一个标签列表；标签出现在标题的末尾。标签是包含字母、数字、‘_’ 和 ‘@’ 的普通单词。标签必须由单个冒号包围，例如 ‘:work:’。可以指定多个标签，例如 ‘:work:urgent:’。默认情况下，标签以粗体显示，并与标题具有相同的颜色。\n标签继承 标签利用了大纲树的层级结构。如果一个标题有特定的标签，那么所有子标题也会继承该标签。例如，在下面的列表中：\n1 2 3 ​* Meeting with the French group :work: ** Summary by Frank :boss:notes: *** TODO Prepare slides for him :action: 最终的标题具有标签 ‘work’，‘boss’，‘notes’，和 ‘action’，即使最终的标题并没有明确标记这些标签。你还可以设置文件中所有条目应该继承的标签，就像这些标签定义在一个假想的零级别，包围整个文件一样。使用如下格式的行来实现：\n1 #+FILETAGS: :Peter:Boss:Secret: 设置标签 标签可以直接在标题末尾输入。在冒号后面，使用 M-TAB 可以对标签进行补全。还有一个用于插入标签的特殊命令：\nC-c C-q (org-set-tags-command) 输入当前标题的新标签。Org mode 提供标签补全或特殊的单键接口来设置标签，见下文。 C-c C-c (org-set-tags-command) 当光标位于标题时，这个命令与 C-c C-q 执行相同的操作。 Org 支持基于标签列表的标签插入。默认情况下，这个列表是动态构建的，包含当前缓冲区中使用的所有标签。你也可以通过变量 org-tag-alist 全局指定一个固定的标签列表。最后，你可以使用 TAGS 关键字为特定文件设置默认标签，例如：\n1 2 #+TAGS: @work @home @tennisclub #+TAGS: laptop car pc sailboat 默认情况下，Org mode 使用标准的 minibuffer 补全功能来输入标签。然而，它也实现了另一种更快速的标签选择方法，称为快速标签选择。此方法允许你通过单个按键来选择和取消选择标签。为了使这一功能发挥作用，你应该为大多数常用标签分配唯一的字母。你可以通过在 Emacs 初始化文件中配置变量 org-tag-alist 来全局设置这些字母。例如，如果你发现需要在不同文件中为许多条目打上 ‘@home’ 标签，你可以设置如下：\n1 (setq org-tag-alist \u0026#39;((\u0026#34;@work\u0026#34; . ?w) (\u0026#34;@home\u0026#34; . ?h) (\u0026#34;laptop\u0026#34; . ?l))) 如果标签仅对你正在处理的文件相关，你可以将 TAGS 关键字设置为：\n1 #+TAGS: @work(w) @home(h) @tennisclub(t) laptop(l) pc(p) 标签组 标签可以被定义为一组其他标签的组标签。组标签可以被看作是其标签集合的“更广泛的术语”。你可以通过使用括号并在组标签和相关标签之间插入冒号来设置组标签：\n1 #+TAGS: [ GTD : Control Persp ] 或者，如果组中的标签应该是互斥的，可以使用花括号：\n1 #+TAGS: { Context : @Home @Work } 当你搜索一个组标签时，它会返回组内及其子组中的所有成员的匹配项。在日程视图中，通过组标签进行筛选时，会显示或隐藏标记有组中至少一个成员或任何子组的标题。如果你想暂时忽略组标签，可以使用 org-toggle-tags-groups 切换组标签支持，该命令绑定在 C-c C-x q。\n标签搜索 C-c / m 或 *C-c * (org-match-sparse-tree) 创建一个稀疏树，显示所有匹配标签搜索的标题。使用 C-u 前缀参数时，忽略非 TODO 行的标题。 M-x org-agenda m (org-tags-view) 从所有日程文件中创建一个全局标签匹配列表。参见“匹配标签和属性”。 M-x org-agenda M (org-tags-view) 从所有日程文件中创建一个全局标签匹配列表，但仅检查 TODO 项目。\n这些命令都会提示输入匹配字符串，允许使用基本的布尔逻辑，比如 +boss+urgent-project1，查找标记为 ‘boss’ 和 ‘urgent’，但不包括 ‘project1’ 的条目，或者 Kathy|Sally，查找标记为 ‘Kathy’ 或 ‘Sally’ 的条目。搜索字符串的完整语法丰富，还允许匹配 TODO 关键字、条目级别和属性。有关更详细的描述和多个示例，请参见“匹配标签和属性”。\n属性 属性是与条目关联的键值对。它们存在于名为 ‘PROPERTIES’ 的特殊抽屉中。每个属性在一行上指定，键（用冒号包围）在前，值在后：\n1 2 3 4 5 6 7 8 9 * CD collection ** Classic *** Goldberg Variations :PROPERTIES: :Title: Goldberg Variations :Composer: J.S. Bach :Publisher: Deutsche Grammophon :NDisks: 1 :END: 你可以通过设置属性 Xyz_ALL 来定义特定属性 Xyz 的允许值。这个特殊的属性是可以继承的，因此如果你在级别 1 的条目中设置它，它会应用于整个树。当定义了允许的值后，设置相应的属性变得更加容易，并且更不容易出现输入错误。例如，对于 CD 收藏，我们可以这样预定义出版商和一个盒子中的磁盘数量：\n1 2 3 4 5 * CD collection :PROPERTIES: :NDisks_ALL: 1 2 3 4 :Publisher_ALL: \u0026#34;Deutsche Grammophon\u0026#34; Philips EMI :END: 如果你想设置可以被文件中任何条目继承的属性，可以使用如下行：\n1 #+PROPERTY: NDisks_ALL 1 2 3 4 以下命令有助于处理属性：\nC-c C-x p (org-set-property) 设置一个属性。此命令会提示输入属性名称和一个值。 C-c C-c d (org-delete-property) 从当前条目中删除一个属性。 要创建基于属性的稀疏树和特殊列表，可以使用与标签搜索相同的命令（参见“标签”）。搜索字符串的语法在“匹配标签和属性”中有描述。\n日期和时间 为了协助项目规划，TODO 项目可以标记日期和时间。携带日期和时间信息的特殊格式字符串在 Org 模式中称为时间戳。这个术语可能会有些令人困惑，因为时间戳通常用于指示某物何时创建或最后何时更改。然而，在 Org 模式中，这个术语的使用范围要广泛得多。时间戳可以用于规划约会、安排任务、设定截止日期、跟踪时间等。以下部分将描述时间戳的格式以及 Org 模式为处理时间和时间间隔的常见用例提供的工具。\n时间戳 时间戳是以特殊格式指定日期——可能还包括时间或时间范围——的说明，例如 \u0026lt;2003-09-16 二\u0026gt;、\u0026lt;2003-09-16 二 09:39\u0026gt; 或 \u0026lt;2003-09-16 二 12:00\u0026gt;–\u0026lt;2003-09-16 二 12:30\u0026gt;。时间戳可以出现在 Org 树条目的标题或正文中的任何位置。其存在会使条目在议程中显示在特定的日期（参见《每周/每日议程》）。我们区分：\n普通时间戳、事件、预约 简单时间戳仅将日期/时间分配给一个条目。这就像在纸质日程表中记录一个预约或事件一样。一个条目中可以有多个时间戳。 1 2 3 4 5 6 7 ​* Meet Peter at the movies \u0026lt;2006-11-01 Wed 19:15\u0026gt; ​* Discussion on climate change \u0026lt;2006-11-02 Thu 20:00-22:00\u0026gt; ​* My days off \u0026lt;2006-11-03 Fri\u0026gt; \u0026lt;2006-11-06 Mon\u0026gt; 时间戳与重复间隔 时间戳可能包含一个重复间隔，表示它不仅适用于给定的日期，还会在经过一定的N小时（h）、天（d）、周（w）、月（m）或年（y）的间隔后重复出现。以下内容将在每周三出现在日程中： 1 2 ​* Pick up Sam at school \u0026lt;2007-05-16 Wed 12:30 +1w\u0026gt; 日记式表达条目 对于更复杂的日期规格，Org 模式支持使用在 Emacs 日历包中实现的特殊表达日记条目。例如，带有可选时间的条目： 1 2 ​* 22:00-23:00 The nerd meeting on every 2nd Thursday of the month \u0026lt;%%(diary-float t 4 2)\u0026gt; 时间范围 时间范围是指两个时间单位通过‘-’连接的时间戳。 1 2 ​* Discussion on climate change \u0026lt;2006-11-02 Thu 10:00-12:00\u0026gt; 时间/日期范围 两个时间戳通过‘\u0026ndash;’连接表示一个范围。在日程中，标题会显示在范围的第一天和最后一天，以及范围内的任何显示日期。第一个示例仅指定了范围的日期，而第二个示例则为每个日期指定了时间范围。 1 2 3 4 ** Meeting in Amsterdam \u0026lt;2004-08-23 Mon\u0026gt;--\u0026lt;2004-08-26 Thu\u0026gt; ** This weeks committee meetings \u0026lt;2004-08-23 Mon 10:00-11:00\u0026gt;--\u0026lt;2004-08-26 Thu 10:00-11:00\u0026gt; 非活动时间戳 与普通时间戳类似，但使用方括号而不是尖括号。这些时间戳是非活动的，即它们不会触发条目在日程中显示。 1 2 ​* Gillian comes late for the fifth time [2006-11-01 Wed] 创建时间戳 为了让 Org 模式识别时间戳，时间戳需要遵循特定的格式。以下所有命令都能生成正确格式的时间戳。\nC-c . (org-timestamp) 提示输入日期并插入相应的时间戳。当光标位于缓冲区中现有的时间戳上时，此命令用于修改该时间戳，而不是插入新的时间戳。当连续使用此命令两次时，会插入一个时间范围。使用前缀参数时，它还会添加当前时间。 C-c ! (org-timestamp-inactive) 与 C-c . 类似，但插入一个非活动时间戳，该时间戳不会导致日程条目出现。 S-LEFT (org-timestamp-down-day) S-RIGHT (org-timestamp-up-day) 将光标处的日期改为前一天或后一天。 S-UP (org-timestamp-up) S-DOWN (org-timestamp-down) 在时间戳的开始或包含括号上，改变其类型。在时间戳内部，改变光标所在的项目。光标可以在年份、月份、日期、小时或分钟上。当时间戳包含时间范围（如‘15:30-16:30’）时，修改第一个时间也会调整第二个时间，从而保持时间段的固定长度。要改变长度，请修改第二个时间。 当 Org 模式提示输入日期/时间时，它接受任何包含日期和/或时间信息的字符串，并智能地解释该字符串，从当前日期和时间推导出未指定信息的默认值。您也可以在弹出日历中选择日期。有关日期/时间提示的详细信息，请参阅手册。\n截止日期与日程安排 时间戳前可以加上特定的关键字以便于计划安排：\nC-c C-d (org-deadline) 在标题下方的行中插入“DEADLINE”关键字及时间戳。意义：任务—很可能是 TODO 项目，尽管不一定—预计在该日期完成。在截止日期当天，任务会出现在日程中。此外，今天的日程还会显示有关即将到期或错过的截止日期的警告，从截止日期前的 org-deadline-warning-days 天开始，直到条目标记为完成为止。一个示例： 1 2 3 *** TODO write article about the Earth for the Guide DEADLINE: \u0026lt;2004-02-29 Sun\u0026gt; The editor in charge is [[bbdb:Ford Prefect]] C-c C-s (org-schedule) 在标题下方的行中插入“SCHEDULED”关键字及时间戳。意义：你计划在给定日期开始处理该任务。标题会在给定日期下列出。此外，今天的汇总中会出现一个提醒，告知计划日期已经过去，直到条目标记为完成，即任务会自动推迟直到完成。 1 2 *** TODO Call Trillian for a date on New Years Eve. SCHEDULED: \u0026lt;2004-12-25 Sat\u0026gt; 有些任务需要反复执行。Org 模式通过在“DEADLINE”、“SCHEDULED”或普通时间戳中使用所谓的重复器来帮助组织这些任务。以下是一个示例：\n1 2 ** TODO Pay the rent DEADLINE: \u0026lt;2005-10-01 Sat +1m\u0026gt; 其中的“+1m”是一个重复器；其含义是该任务的截止日期是“\u0026lt;2005-10-01 六\u0026gt;”，并且从那时起每个月重复一次。\n记录工作时间 Org 模式允许你记录在项目中特定任务上花费的时间。\nC-c C-x C-i (org-clock-in) 开始记录当前项目的时间（记录开始）。这会插入“CLOCK”关键字和一个时间戳。当使用 C-u 前缀参数调用时，可以从最近记录的任务列表中选择任务。 C-c C-x C-o (org-clock-out) 停止记录时间（记录结束）。这会在上次启动计时的位置插入另一个时间戳，并直接计算结果时间并以“=\u0026gt;HH”的格式插入在时间范围之后。 C-c C-x C-e (org-clock-modify-effort-estimate) 更新当前计时任务的工作量估算。 C-c C-x C-q (org-clock-cancel) 取消当前计时。这在计时错误启动或转而处理其他任务时非常有用。 C-c C-x C-j (org-clock-goto) 跳转到当前计时任务的标题。使用 C-u 前缀参数时，从最近记录的任务列表中选择目标任务。 在日程中可以使用 l 键（参见《每周/每日日程》）来显示在一天内被处理或关闭的任务。\n捕捉、归档、存档 任何组织系统的重要部分是能够快速捕捉新的想法和任务，并将相关的参考资料与其关联。 Org 模式通过一个叫做捕捉（capture）的过程来实现这一点。它还可以将与任务相关的文件（附件）存储在一个特殊目录中。任务和项目一旦进入系统，需要进行移动。将完成的项目树移动到归档文件中可以保持系统的紧凑和高效。\n捕捉 捕捉功能让你可以在工作流程中几乎没有中断地快速存储笔记。你可以为新的条目定义模板，并将它们关联到不同的目标位置以存储笔记。\n设置捕捉 以下自定义设置了一个默认的笔记目标文件： 1 (setq org-default-notes-file (concat org-directory \u0026#34;/notes.org\u0026#34;)) 你还可以为捕捉新资料定义一个全局快捷键（见激活）。 使用捕捉 M-x org-capture (org-capture) 启动捕捉过程，将你置于一个缩小的间接缓冲区中进行编辑。 C-c C-c (org-capture-finalize) 在你完成在捕捉缓冲区中输入信息后，按 C-c C-c 将你带回到捕捉过程之前的窗口配置，以便你可以继续工作而不再受到干扰。 C-c C-w (org-capture-refile) 通过将笔记重新归档到不同的位置来完成捕捉过程（参见 归档和复制）。 C-c C-k (org-capture-kill) 中止捕捉过程并返回到之前的状态。 捕捉模板 你可以为不同类型的捕捉条目和不同的目标位置使用模板。例如，你希望使用一个模板来创建一般的 TODO 条目，并将这些条目放在文件 ~/org/gtd.org 中的“Tasks”标题下。同时，文件 journal.org 中的日期树应该用于捕捉日记条目。一个可能的配置如下： 1 2 3 4 5 (setq org-capture-templates \u0026#39;((\u0026#34;t\u0026#34; \u0026#34;Todo\u0026#34; entry (file+headline \u0026#34;~/org/gtd.org\u0026#34; \u0026#34;Tasks\u0026#34;) \u0026#34;* TODO %?\\n %i\\n %a\u0026#34;) (\u0026#34;j\u0026#34; \u0026#34;Journal\u0026#34; entry (file+datetree \u0026#34;~/org/journal.org\u0026#34;) \u0026#34;* %?\\nEntered on %U\\n %i\\n %a\u0026#34;))) 如果你从捕捉菜单中按下 t，Org 会为你准备模板，如下所示： 1 2 ​* TODO [[file:LINK TO WHERE YOU INITIATED CAPTURE]] 在模板展开过程中，特殊的 %-转义字符允许动态插入内容。以下是一些可能性的小选集，详细信息请参阅手册：‘%a’ 注释，通常是通过 org-store-link 创建的链接‘%i’ 初始内容，当捕捉使用 C-u 调用时的区域‘%t’，‘%T’ 时间戳，仅日期，或日期和时间‘%u’，‘%U’ 如上，但为非活动时间戳‘%?’ 完成模板后，光标位置 归档和复制 在审查捕捉的数据时，你可能想将一些条目重新归档或复制到不同的列表中，例如项目。剪切、找到正确的位置，然后粘贴笔记是繁琐的。为了简化这一过程，你可以使用以下特殊命令：\nC-c C-w (org-agenda-refile) 将光标处的条目或区域重新归档。此命令提供可能的归档位置，并让你通过自动补全选择一个。条目（或区域中的所有条目）会作为子项归档到目标标题下。默认情况下，当前缓冲区中的所有 1 级标题都被视为目标，但你可以在多个文件中定义更复杂的目标。有关详细信息，请参见变量 org-refile-targets。 C-u C-c C-w (org-agenda-refile) 使用归档界面跳转到一个标题。 C-u C-u C-c C-w (org-refile-goto-last-stored) 跳转到 org-refile 上次移动树的位置。 C-c M-w (org-refile-copy) 复制的工作方式与归档类似，只是原始笔记不会被删除。 归档 当一个由（子）树表示的项目完成时，你可能希望将该树移到其他地方，并停止它对日程的影响。归档对于保持工作文件的紧凑性和确保全局搜索（如构建日程视图）的速度非常重要。最常见的归档操作是将项目树移动到另一个文件，即归档文件。\nC-c C-x C-a (org-archive-subtree-default) 使用 org-archive-default-command 变量中指定的命令归档当前条目。 C-c C-x C-s 或简写为 C-c $ (org-archive-subtree) 将光标位置开始的子树归档到由 org-archive-location 给定的位置。 默认的归档位置是与当前文件位于同一目录中的文件，其名称是将“_archive”附加到当前文件名后形成的。你还可以选择归档条目归档到哪个标题下，也可以将其添加到文件中的日期树中。有关如何指定文件和标题的信息和示例，请参见变量 org-archive-location 的文档字符串。在缓冲区内也可以设置此变量，例如：\n1 #+ARCHIVE: %s_done:: 议程视图 由于 Org 的工作方式，TODO 项目、带时间戳的项目和标记的标题可能会分散在一个文件中，甚至在多个文件中。为了获得开放的行动项目或特定日期的重要事件的概览，需要将这些信息收集、排序并以有组织的方式展示出来。提取的信息会显示在一个特殊的议程缓冲区中。这个缓冲区是只读的，但提供了访问原始 Org 文件中相应位置的命令，甚至可以远程编辑这些文件。从议程缓冲区进行远程编辑意味着，例如，你可以在议程缓冲区中更改截止日期和约会的日期。有关议程缓冲区中可用命令的更多信息，请参见议程缓冲区中的命令。\n议程文件 要显示的信息通常会从所有议程文件中收集，这些文件列在变量 org-agenda-files 中。\nC-c [ (org-agenda-file-to-front) 将当前文件添加到议程文件列表中。文件会被添加到列表的前面。如果它已经在列表中，它会被移到前面。如果使用前缀参数，文件会被添加/移动到列表的末尾。 C-c ] (org-remove-file) 从议程文件列表中移除当前文件。 C-\u0026rsquo; C-, (org-cycle-agenda-files) 循环浏览议程文件列表，依次访问每个文件。 议程调度器 视图是通过调度器创建的，可以通过 M-x org-agenda 访问，或者更好的是，绑定到全局快捷键（见激活）。调度器显示一个菜单，需要额外的字母来执行命令。调度器提供了以下默认命令：\na 创建类似日历的议程（见《每周/每日议程》）。\nt、T 创建所有 TODO 项目的列表（见《全局 TODO 列表》）。\nm、M 创建匹配给定表达式的标题列表（见《匹配标签和属性》）。\ns 创建通过布尔表达式选择的条目列表，表达式由关键字和/或正则表达式组成，这些关键字和/或正则表达式必须或必须不出现于条目中。\n每周/每日议程 每周/每日议程的目的是像纸质日程表的一页一样，显示当前一周或一天的所有任务。\nM-x org-agenda a (org-agenda-list) 从 Org 文件列表中编译当前周的议程。议程会显示每一天的条目。 Org 模式理解日历的语法，并允许你在 Org 文件中直接使用日历表达式条目：\n1 2 3 4 5 6 7 8 9 10 11 12 * Holidays :PROPERTIES: :CATEGORY: Holiday :END: %%(org-calendar-holiday) ; special function for holiday names * Birthdays :PROPERTIES: :CATEGORY: Ann :END: %%(org-anniversary 1956 5 14) Arthur Dent is %d years old %%(org-anniversary 1869 10 2) Mahatma Gandhi would be %d years old Org 还可以与 Emacs 的预约通知功能互动。要将议程文件的预约添加到通知中，可以使用命令 org-agenda-to-appt。\n全局 TODO 列表 全局 TODO 列表包含所有未完成的 TODO 项目，并将其格式化并集中到一个地方。远程编辑 TODO 项目使你可以通过单个按键来更改 TODO 条目的状态。有关 TODO 列表中可用的命令，请参见《议程缓冲区中的命令》。\nM-x org-agenda t (org-todo-list) 显示全局 TODO 列表。该列表将所有议程文件中的 TODO 项目（见《议程视图》）收集到一个缓冲区中。 M-x org-agenda T (org-todo-list) 与上面的命令类似，但允许选择特定的 TODO 关键字。 匹配标签和属性 如果议程文件中的标题标记了标签（见《标签》）或具有属性（见《属性》），你可以根据这些元数据选择标题，并将它们收集到议程缓冲区中。这里描述的匹配语法在创建稀疏树时也适用（按 C-c / m）。\nM-x org-agenda m (org-tags-view) 生成一个所有匹配给定标签集的标题列表。该命令会提示输入选择标准，这是一种使用标签的布尔逻辑表达式，例如 +work+urgent-withboss 或 work|home（见《标签》）。如果你经常需要特定的搜索，可以为其定义一个自定义命令（见《议程调度器》）。 M-x org-agenda M (org-tags-view) 类似于上面的命令，但仅选择那些也是 TODO 项目的标题。 搜索字符串可以使用布尔操作符 \u0026amp; 代表 AND 和 | 代表 OR。\u0026amp; 的优先级高于 |。目前不支持括号。搜索中的每个元素可以是标签、匹配标签的正则表达式，或者像 PROPERTY OPERATOR VALUE 这样的表达式，其中包含比较操作符，用于访问属性值。每个元素前可以加 - 来表示排除，并且 + 是正选的语法糖。当存在 + 或 - 时，AND 操作符 \u0026amp; 是可选的。以下是一些示例，仅使用标签：\n+work-boss 选择标记为 work 的标题，但排除那些也标记为 boss 的标题。 work|laptop 选择标记为 work 或 laptop 的标题。 work|laptop+night 类似于之前的命令，但要求标记为 laptop 的标题也必须标记为 night。 你还可以同时测试属性与匹配标签，详情请参阅手册。\n搜索视图 此议程视图是一个通用的文本搜索功能，用于 Org 模式条目。它特别有用来查找笔记。\nM-x org-agenda s (org-search-view) 这是一个特殊的搜索功能，可以通过匹配子字符串或特定单词来选择条目，支持布尔逻辑。 例如，搜索字符串 ‘computer equipment’ 匹配包含 ‘computer equipment’ 作为子字符串的条目。搜索视图还可以使用布尔逻辑搜索条目中的特定关键字。搜索字符串 ‘+computer +wifi -ethernet -{8\\.11[bg]}’ 匹配包含关键字 ‘computer’ 和 ‘wifi’ 的条目，但不包含关键字 ‘ethernet’，并且也不匹配正则表达式 ‘8\\.11[bg]’，即排除 ‘8.11b’ 和 ‘8.11g’。请注意，除了议程文件之外，此命令还会搜索 org-agenda-text-search-extra-files 列出的文件。\n议程缓冲区中的命令 议程缓冲区中的条目链接回它们来源的 Org 文件或日历文件。你不能直接编辑议程缓冲区本身，但提供了命令来显示并跳转到原始条目位置，并从议程缓冲区“远程”编辑 Org 文件。这只是众多命令中的一部分，查看议程菜单和手册以获取完整列表。\n移动 n (org-agenda-next-line) 下一行（与 DOWN 和 C-n 相同）。 p (org-agenda-previous-line) 上一行（与 UP 和 C-p 相同）。 查看/跳转到 Org 文件 SPC (org-agenda-show-and-scroll-up) 在另一个窗口中显示条目的原始位置。使用前缀参数时，确保抽屉保持折叠状态。 TAB (org-agenda-goto) 跳转到条目的原始位置，在另一个窗口中打开。 RET (org-agenda-switch-to) 跳转到条目的原始位置，并关闭其他窗口。 更改显示 o (delete-other-windows) 关闭其他窗口。 v d 或 短 d (org-agenda-day-view) 切换到天视图。 v w 或 短 w (org-agenda-week-view) 切换到周视图。 f (org-agenda-later) 向未来推进，显示当前时间段之后的内容。例如，如果当前显示的是一周，切换到下一周。 b (org-agenda-earlier) 向过去推进，显示更早的日期。 . (org-agenda-goto-today) 跳转到今天。 j (org-agenda-goto-date) 提示输入一个日期并跳转到该日期。 v l 或 v L 或 短 l (org-agenda-log-mode) 切换到日志模式。在日志模式下，显示在日志开启时标记为完成的条目（见变量 org-log-done），以及当天已记录时间的条目。当使用 C-u 前缀参数调用时，显示所有可能的日志条目，包括状态变化。 r g (org-agenda-redo) 重新创建议程缓冲区，例如在修改条目的时间戳后更新显示。 s (org-save-all-org-buffers) 保存当前 Emacs 会话中的所有 Org 缓冲区，以及 ID 的位置。 远程编辑 0\u0026ndash;9 数字参数。 t (org-agenda-todo) 更改条目的 TODO 状态，同时在议程和原始 Org 文件中进行更新。 C-k (org-agenda-kill) 删除当前议程项目及其在原始 Org 文件中所属的整个子树。 C-c C-w (org-agenda-refile) 重新归档光标所在的条目。 a (org-agenda-archive-default-with-confirmation) 使用在 org-archive-default-command 中设置的默认归档命令归档光标所在条目对应的子树，并要求确认。 $ (org-agenda-archive) 归档当前标题对应的子树。 C-c C-s (org-agenda-schedule) 为该条目安排时间。使用前缀参数时，移除安排的时间戳。 C-c C-d (org-agenda-deadline) 为该条目设置截止日期。使用前缀参数时，移除截止日期。 S-RIGHT (org-agenda-do-date-later) 将当前行关联的时间戳提前一天。 S-LEFT (org-agenda-do-date-earlier) 将当前行关联的时间戳推迟一天。 I (org-agenda-clock-in) 开始记录当前条目的时间。 O (org-agenda-clock-out) 停止之前开始的时间记录。 X (org-agenda-clock-cancel) 取消当前正在运行的时间记录。 J (org-agenda-clock-goto) 跳转到另一个窗口中的正在运行的时间记录。 退出和退出 q (org-agenda-quit) 退出议程，关闭议程缓冲区。 x (org-agenda-exit) 退出议程，关闭议程缓冲区以及所有为编译议程而加载的 Emacs 缓冲区。 自定义议程视图 自定义搜索的第一个应用是为常用的搜索定义键盘快捷键，这些搜索可以是创建议程缓冲区，也可以是稀疏树（后者仅适用于当前缓冲区）。自定义命令在变量 org-agenda-custom-commands 中配置。你可以通过在议程调度器中按 C 来自定义此变量（见《议程调度器》）。也可以直接在 Emacs 初始化文件中使用 Emacs Lisp 进行设置。以下示例包含所有有效的议程视图：\n1 2 3 4 (setq org-agenda-custom-commands \u0026#39;((\u0026#34;w\u0026#34; todo \u0026#34;WAITING\u0026#34;) (\u0026#34;u\u0026#34; tags \u0026#34;+boss-urgent\u0026#34;) (\u0026#34;v\u0026#34; tags-todo \u0026#34;+boss-urgent\u0026#34;))) 每个条目中的初始字符串定义了在调度器命令后需要按下的键，以便访问该命令。通常这只是一个字符。第二个参数是搜索类型，后跟用于匹配的字符串或正则表达式。上述示例将定义：\nw 作为一个全局搜索，查找 TODO 条目中关键字为 WAITING 的条目。 u 作为一个全局标签搜索，查找标记为 boss 但不标记为 urgent 的标题。 v 同样的搜索，但限制为那些也是 TODO 项目的标题。 富内容的标记 Org 主要用于组织和搜索纯文本笔记。然而，它也提供了一种轻量但强大的标记语言，用于富文本格式化及其他功能。与导出框架（见《导出》）结合使用时，你可以在 Org 中创作出美观的文档。\n段落 段落之间至少有一个空行。如果您需要在段落内强制换行，请使用 \u0026lsquo;\\\\\u0026rsquo; 在行末。为了保留区域中的换行符、缩进和空行，但在其他方面使用正常格式，您可以使用此构造，它也可以用于格式化诗歌。\n1 2 3 4 5 6 7 #+BEGIN_VERSE Great clouds overhead Tiny black birds rise and fall Snow covers Emacs ---AlexSchroeder #+END_VERSE 引用另一份文档中的一段文字时，通常将其格式化为左右边距均缩进的段落。您可以像这样在 Org 文档中包含引文：\n1 2 3 4 #+BEGIN_QUOTE Everything should be made as simple as possible, but not any simpler ---Albert Einstein #+END_QUOTE 如果您想要将一些文本居中，请这样做：\n1 2 3 4 #+BEGIN_CENTER Everything should be made as simple as possible, \\\\ but not any simpler #+END_CENTER 强调和等宽字体 你可以造词\u0026rsquo;大胆的\u0026rsquo;，\u0026rsquo;斜体\u0026rsquo;，\u0026rsquo;_下划线_\u0026rsquo;，\u0026rsquo;逐字\u0026rsquo; 和 \u0026lsquo;代码\u0026rsquo;，如果你必须，\u0026rsquo;删除线\u0026rsquo;. 代码和逐字字符串中的文本不会根据 Org 特定语法进行处理；而是逐字导出。\n嵌入式 LaTeX 对于需要包含数学符号和偶尔出现的公式的科学笔记，Org 模式支持将 LaTeX 代码嵌入到其文件中。您可以直接使用类似 TeX 的语法来输入特殊符号、公式和整个 LaTeX 环境。\n1 2 3 4 5 6 7 8 9 The radius of the sun is R_sun = 6.96 x 10^8 m. On the other hand, the radius of Alpha Centauri is R_{Alpha Centauri} = 1.28 x R_{sun}. \\begin{equation} % arbitrary environments, x=\\sqrt{b} % even tables, figures \\end{equation} % etc If $a^2=b$ and \\( b=2 \\), then the solution must be either $$ a=+\\sqrt{2} $$ or \\[ a=-\\sqrt{2} \\]. 文字示例 您可以添加不应受标记约束的文字示例。此类示例采用等宽字体排版，因此非常适合源代码和类似示例。\n1 2 3 #+BEGIN_EXAMPLE Some example from a text file. #+END_EXAMPLE 为了在使用小示例时简单起见，您还可以以冒号加空格作为示例行的开头。冒号前还可以有额外的空格：\n1 2 Here is an example : Some example from a text file. 如果示例是来自编程语言的源代码，或者任何其他可以通过 Emacs 中的 Font Lock 标记的文本，您可以要求示例看起来像字体化的 Emacs 缓冲区。\n1 2 3 4 5 #+BEGIN_SRC emacs-lisp (defun org-xor (a b) \u0026#34;Exclusive or.\u0026#34; (if a (not b) b)) #+END_SRC 要在支持该语言的特殊缓冲区中编辑示例，请使用 C-c \u0026lsquo;进入和离开编辑缓冲区。\n图像 图像是指向没有描述部分的图像文件的链接，例如\n1 ./img/cat.jpg 如果您希望为图像定义标题，或者为内部交叉引用定义标签（请参阅超链接），请确保链接单独成行，并在其前面加上 \u0026lsquo;标题\u0026rsquo; 和 \u0026lsquo;姓名\u0026rsquo; 关键字如下：\n1 2 3 #+CAPTION: This is the caption for the next figure link (or table) #+NAME: fig:SED-HR4049 [[./img/a.jpg]] 创建脚注 脚注在段落中定义，以第 0 列中方括号内的脚注标记开头，不允许缩进。脚注引用只是文本中方括号内的标记。例如：\n1 2 3 The Org website[fn:1] now looks a lot better than it used to. ... [fn:1] The link is: https://orgmode.org 以下命令处理脚注：\nC-c C-x f（org-footnote-action）\n脚注操作命令。当光标位于脚注引用上时，跳转到定义。当光标位于定义上时，跳转到（第一个）引用。否则，创建一个新的脚注。当使用前缀参数调用此命令时，会提供一个附加选项菜单，包括重新编号。\nC-c C-c（org-ctrl-c-ctrl-c） 在定义和参考之间跳转。\n导出 org 可以将文档转换并导出为多种其他格式，同时尽可能保留文档的结构（参见文档结构）和标记（参见富文本标记）。\n导出调度器 导出调度器是 Org 导出的主要界面。一个层级菜单展示了当前配置的导出格式。选项以简易切换开关的形式显示在同一屏幕上。\nC-c C-e (org-export-dispatch) 调用导出调度器界面。 默认情况下，Org 会导出整个缓冲区。如果 Org 缓冲区中有活动区域，则 Org 只导出该区域。\n导出设置 导出器会识别缓冲区中的特殊行，以提供额外的信息。这些行可以放置在文件中的任何位置：\n1 #+TITLE: I\u0026#39;m in the Mood for Org 主要的导出选项包括：\n‘TITLE’：要显示的标题 ‘AUTHOR’：作者（默认为 user-full-name） ‘DATE’：日期，可以是固定日期或 Org 时间戳 ‘EMAIL’：电子邮件地址（默认为 user-mail-address） ‘LANGUAGE’：语言代码，例如 \u0026rsquo;en\u0026rsquo; 可以通过在导出调度器中使用 \u0026lsquo;Insert template\u0026rsquo; 命令（按 # 键）来插入选项关键字集。\n目录 目录包括文档中的所有标题。因此，其深度与文件中的标题级别相同。如果需要使用不同的深度或完全关闭目录，请相应地设置 org-export-with-toc 变量。您也可以在每个文件中使用以下 OPTIONS 关键字项来实现相同的效果：\n1 2 #+OPTIONS: toc:2 (only include two levels in TOC) #+OPTIONS: toc:nil (no default TOC at all) Org 通常会在文件的第一个标题之前直接插入目录。\n包含文件 在导出过程中，您可以包含另一个文件的内容。例如，要包含您的 .emacs 文件，可以使用：\n1 #+INCLUDE: \u0026#34;~/.emacs\u0026#34; src emacs-lisp 第一个参数是要包含的文件名。可选的第二个参数指定块类型：‘example’，‘export’ 或 ‘src’。可选的第三个参数指定用于格式化内容的源代码语言。这与 ‘export’ 和 ‘src’ 块类型相关。您可以通过 C-c \u0026rsquo; 访问包含的文件。\n注释行 以零个或多个空白字符开头，紧接着一个 # 和一个空白字符的行被视为注释，因此不会被导出。同样，被 \u0026lsquo;#+BEGIN_COMMENT … #+END_COMMENT\u0026rsquo; 包围的区域也不会被导出。最后，条目开头的 COMMENT 关键字（但在其他任何关键字或优先级标记之后）会注释掉整个子树。下面的命令有助于切换标题的注释状态。\nC-c ; (org-toggle-comment) 切换条目开头的 COMMENT 关键字。 ASCII/UTF-8 导出 ASCII 导出生成的输出文件仅包含纯 ASCII 字符。这是最简单和直接的文本输出方式，不包含任何 Org 标记。 UTF-8 导出使用了该编码标准中可用的附加字符和符号。\nC-c C-e t a C-c C-e t u (org-ascii-export-to-ascii) 以 .txt 扩展名导出为 ASCII 文件。对于 myfile.org，Org 会导出为 myfile.txt，并会覆盖原文件而不发出警告。对于 myfile.txt，Org 会导出为 myfile.txt.txt 以防数据丢失。 HTML 导出 Org 模式包含一个 HTML 导出器，具有与 XHTML 1.0 严格标准兼容的广泛 HTML 格式化功能。\nC-c C-e h h (org-html-export-to-html) 以 .html 扩展名导出为 HTML 文件。对于 myfile.org，Org 会导出为 myfile.html，并会覆盖原文件而不发出警告。 C-c C-e h o 将导出为 HTML 并在网页浏览器中打开。 HTML 导出后端将 \u0026lt; 和 \u0026gt; 转换为 \u0026amp;lt; 和 \u0026amp;gt;。要在 Org 文件中包含原始 HTML 代码，以便 HTML 导出后端可以将这些 HTML 代码插入到输出中，可以使用这种内联语法：\u0026rsquo;\u0026hellip;\u0026rsquo;。例如：\n1 @@html:\u0026lt;b\u0026gt;@@bold text@@html:\u0026lt;/b\u0026gt;@@ 对于较大的原始 HTML 代码块，可以使用以下 HTML 导出代码块：\n1 2 3 4 5 #+HTML: Literal HTML code for export #+BEGIN_EXPORT html All lines between these markers are exported literally #+END_EXPORT LaTeX 导出 LaTeX 导出后端可以处理复杂的文档，结合标准或自定义的 LaTeX 文档类，使用不同的 LaTeX 引擎生成文档，并生成完全链接的 PDF 文件，包括索引、参考文献和目录，适用于互动在线查看或高质量印刷出版。默认情况下，LaTeX 输出使用 article 类。您可以通过在文件中添加类似 #+LATEX_CLASS: myclass 的选项来更改此设置。类名必须列在 org-latex-classes 中。\nC-c C-e l l (org-latex-export-to-latex) 导出为 .tex 扩展名的 LaTeX 文件。对于 myfile.org，Org 会导出为 myfile.tex，并会覆盖原文件而不发出警告。 C-c C-e l p (org-latex-export-to-pdf) 导出为 LaTeX 文件并转换为 PDF 文件。 C-c C-e l o (\u0026lt;没有对应的命名命令\u0026gt;)\n导出为 LaTeX 文件并转换为 PDF，然后使用默认查看器打开 PDF。 LaTeX 导出后端可以插入任何任意的 LaTeX 代码，参见嵌入 LaTeX。将此代码嵌入 Org 文件有三种方式，它们使用不同的引号语法。插入内联代码，使用 @ 符号引用：\n1 Code embedded in-line @@latex:any arbitrary LaTeX code@@ in a paragraph. 作为一个或多个关键字行插入到 Org 文件中：\n1 #+LATEX: any arbitrary LaTeX code 作为导出块插入到 Org 文件中，其中后端会导出开始和结束标记之间的所有代码：\n1 2 3 #+BEGIN_EXPORT latex any arbitrary LaTeX code #+END_EXPORT iCalendar 导出 Org 模式的一个重要互操作性优势是它能够轻松地导出到或从外部应用程序导入。 iCalendar 导出后端从 Org 文件中提取日历数据并导出为标准 iCalendar 格式。\nC-c C-e c f (org-icalendar-export-to-ics) 从当前 Org 缓冲区创建 iCalendar 条目，并将其存储在相同目录中，文件扩展名为 .ics。 C-c C-e c c (org-icalendar-combine-agenda-files) 从 org-agenda-files 中的 Org 文件创建一个合并的 iCalendar 文件，并将其写入 org-icalendar-combined-agenda-file 文件名中。 发布 Org 包含一个发布管理系统，允许您配置项目的自动 HTML 转换，这些项目由互联的 Org 文件组成。您还可以配置 Org 以自动将导出的 HTML 页面和相关附件（如图像和源代码文件）上传到 Web 服务器。您还可以使用 Org 将文件转换为 PDF，甚至可以将 HTML 和 PDF 转换结合起来，使文件在服务器上同时提供这两种格式。有关设置的详细说明，请参阅手册。以下是一个示例：\n1 2 3 4 5 6 7 8 9 10 (setq org-publish-project-alist \u0026#39;((\u0026#34;org\u0026#34; :base-directory \u0026#34;~/org/\u0026#34; :publishing-function org-html-publish-to-html :publishing-directory \u0026#34;~/public_html\u0026#34; :section-numbers nil :with-toc nil :html-head \u0026#34;\u0026lt;link rel=\\\u0026#34;stylesheet\\\u0026#34; href=\\\u0026#34;../other/mystyle.css\\\u0026#34; type=\\\u0026#34;text/css\\\u0026#34;/\u0026gt;\u0026#34;))) C-c C-e P x (org-publish) 提示选择特定的项目，并发布所有属于该项目的文件。 C-c C-e P p (org-publish-current-project) 发布包含当前文件的项目。 C-c C-e P f (org-publish-current-file) 仅发布当前文件。 C-c C-e P a (org-publish-all) 发布所有项目。 Org 使用时间戳来跟踪文件的更改。上述功能通常只发布已更改的文件。您可以通过在任何命令前加上前缀参数来覆盖此设置，强制发布所有文件。\n处理源代码 Org 模式提供了许多处理源代码的功能，包括在其原生主要模式下编辑代码块、评估代码块、整理代码块以及以多种格式导出代码块及其结果。源代码块的结构如下：\n1 2 3 4 #+NAME: \u0026lt;name\u0026gt; #+BEGIN_SRC \u0026lt;language\u0026gt; \u0026lt;switches\u0026gt; \u0026lt;header arguments\u0026gt; \u0026lt;body\u0026gt; #+END_SRC 其中：\n\u0026lt;name\u0026gt; 是用于唯一标识代码块的字符串， \u0026lt;language\u0026gt; 指定代码块的语言，例如 emacs-lisp、shell、R、python 等， \u0026lt;switches\u0026gt; 可用于控制代码块的导出， \u0026lt;header arguments\u0026gt; 可用于控制代码块行为的许多方面，如下所示， \u0026lt;body\u0026gt; 包含实际的源代码。 使用 C-c \u0026rsquo; 来编辑当前的代码块。这将打开一个新的主要模式编辑缓冲区，包含源代码块的主体，准备进行任何编辑。再次使用 C-c \u0026rsquo; 来关闭缓冲区并返回到 Org 缓冲区。\n使用头部参数 头部参数以初始的冒号开始，后跟参数名称（小写字母）。头部参数可以通过多种方式设置；如果出现重叠或冲突，Org 会优先考虑本地设置。\n系统范围的头部参数 这些参数通过自定义 org-babel-default-header-args 变量指定，或者对于特定语言 LANG，通过 org-babel-default-header-args:LANG 进行指定。 属性中的头部参数 您可以使用 header-args 属性设置头部参数（参见属性）——对于语言 LANG，使用 header-args:LANG。通过属性抽屉设置的头部参数适用于子树级别及以下。 代码块中的头部参数 头部参数通常在源代码块级别设置，在 BEGIN_SRC 行上： 1 2 3 4 5 #+NAME: factorial #+BEGIN_SRC haskell :results silent :exports code :var n=0 fac 0 = 1 fac n = n * fac (n-1) #+END_SRC 代码块的头部参数可以使用 \u0026lsquo;HEADER\u0026rsquo; 关键字分多行指定，每行一个。 评估代码块 使用 C-c C-c 来评估当前代码块并将其结果插入到 Org 文档中。默认情况下，评估只对 emacs-lisp 代码块启用，但也支持评估多种语言的代码块。有关支持的语言的完整列表，请参见手册。以下示例显示了一个代码块及其结果。\n1 2 3 4 5 6 #+BEGIN_SRC emacs-lisp (+ 1 2 3 4) #+END_SRC #+RESULTS: : 10 以下语法用于通过 var 头部参数将参数传递给代码块。\n1 :var=NAME=ASSIGN 其中，NAME 是在代码块主体中绑定的变量名。ASSIGN 是一个字面值，例如字符串、数字、表格引用、列表、字面示例、另一个代码块（无论是否有参数）或评估代码块的结果。\n评估结果 Org 如何处理代码块执行的结果取决于多个头部参数的配合。主要的决定因素是 results 头部参数。它控制代码块结果的收集、类型、格式和处理方式。\n收集 如何从代码块中收集结果。您可以选择 output 或 value（默认值）。 类型 预期代码块执行的结果类型。您可以选择 table、list、scalar 或 file。如果未提供，Org 会尝试猜测结果类型。 格式 Org 如何处理结果。一些可能的值包括 code、drawer、html、latex、link 和 raw。 处理方式 如何在适当格式化后插入结果。允许的值有 silent、replace（默认值）、append 或 prepend。 将结果输出到文件的代码块，例如：图表、图形和图示，可以接受 :file FILENAME 头部参数，在这种情况下，结果会保存到指定的文件中，并在缓冲区中插入一个指向该文件的链接。\n导出代码块 可以导出代码块的代码、代码块评估的结果、代码和评估结果两者，或不导出任何内容。Org 默认情况下会为大多数语言导出代码。 exports 头部参数用于指定该部分 Org 文件是否导出为 HTML 或 LaTeX 格式。它可以设置为 code、results、both 或 none。\n提取源代码 使用 C-c C-v t 从当前缓冲区的源代码块中提取代码，创建纯源代码文件。这称为“整理”（tangling）——这是一个来自文献化编程社区的术语。在整理代码块时，其主体会通过 org-babel-expand-src-block 展开，该函数可以展开变量和“Noweb”风格的引用。要整理代码块，它必须具有 tangle 头部参数，详细信息请参见手册。\n杂项 补全 Org 提供了在缓冲区内的补全功能，使用 M-TAB 键，无需使用 minibuffer。输入一个或多个字母，然后调用快捷键以原位完成文本。例如，此命令将补全 TeX 符号（在 \\ 后）、标题开头的 TODO 关键字，以及标题中 : 后的标签。\n结构模板 要快速插入空的结构块，例如 #+BEGIN_SRC … #+END_SRC，或将现有文本包裹在这样的块中，可以使用：\nC-c C-, (org-insert-structure-template) 提示选择一个块结构的类型，并在光标位置插入该块。如果区域是活动的，它将被包裹在块中。 清晰视图 Org 的默认大纲使用星号和无缩进，对于短文档可能会显得过于杂乱。对于书籍般的长文档，效果则不那么显著。Org 提供了一种替代的星号和缩进方案，如下表右侧所示。它只使用一个星号，并将文本缩进与标题对齐：\n1 2 3 4 5 6 7 * Top level headline | * Top level headline ** Second level | * Second level *** Third level | * Third level some text | some text *** Third level | * Third level more text | more text * Another top level headline | * Another top level headline 这种视图可以通过在显示时动态实现，使用 Org Indent 模式（M-x org-indent-mode RET），该模式在每行前添加不可见的空间。您可以通过自定义变量 org-startup-indented 来为所有文件启用 Org Indent 模式，或使用以下方式为单个文件启用它：\n1 #+STARTUP: indent 如果您希望缩进使用硬空格字符，以便纯文本文件与 Emacs 显示尽可能相似， Org 可以通过以下方式支持您：在每个标题下缩进（使用 TAB），隐藏前导星号，并且仅使用 1、3 等级别来为每个级别提供两个字符的缩进。要在文件中启用这种支持，请使用：\n1 #+STARTUP: hidestars odd ","date":"2024-07-27T00:00:00Z","permalink":"https://JanSky520.github.io/p/org%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97/","title":"org快速指南"}]